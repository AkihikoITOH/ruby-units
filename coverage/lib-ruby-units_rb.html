    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>lib/ruby-units.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
        <p>Generated on Wed Sep 20 18:59:47 EDT 2006 with <a href='http://eigenclass.org/hiki.rb?rcov'>rcov 0.7.0</a>
        </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='lib-ruby-units_rb.html'>lib/ruby-units.rb</a>
          </td>
          <td class='value'>
            <tt>1088</tt>
          </td>
          <td class='value'>
            <tt>812</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt>99.3%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='99' />
                      <td class='uncovered' width='1' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt>99.0%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='99' />
                      <td class='uncovered' width='1' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="marked1"><a name="line1" />   1 require 'mathn'
</span><span class="marked0"><a name="line2" />   2 require 'rational'
</span><span class="marked1"><a name="line3" />   3 require 'date'
</span><span class="marked0"><a name="line4" />   4 require 'parsedate'
</span><span class="inferred1"><a name="line5" />   5 # = Ruby Units 0.2.3
</span><span class="inferred0"><a name="line6" />   6 #
</span><span class="inferred1"><a name="line7" />   7 # Copyright 2006 by Kevin C. Olbrich, Ph.D.
</span><span class="inferred0"><a name="line8" />   8 # 
</span><span class="inferred1"><a name="line9" />   9 # See http://rubyforge.org/ruby-units/
</span><span class="inferred0"><a name="line10" />  10 #
</span><span class="inferred1"><a name="line11" />  11 # http://www.sciwerks.org
</span><span class="inferred0"><a name="line12" />  12 #
</span><span class="inferred1"><a name="line13" />  13 # mailto://kevin.olbrich+ruby-units@gmail.com
</span><span class="inferred0"><a name="line14" />  14 #
</span><span class="inferred1"><a name="line15" />  15 # See README for detailed usage instructions and examples
</span><span class="inferred0"><a name="line16" />  16 #
</span><span class="inferred1"><a name="line17" />  17 # ==Unit Definition Format
</span><span class="inferred0"><a name="line18" />  18 #
</span><span class="inferred1"><a name="line19" />  19 #  '&lt;name&gt;'  =&gt; [%w{prefered_name synonyms}, conversion_to_base, :classification, %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;numerator&gt;} , %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;denominator&gt;} ],
</span><span class="inferred0"><a name="line20" />  20 #
</span><span class="inferred1"><a name="line21" />  21 # Prefixes (e.g., a :prefix classification) get special handling
</span><span class="inferred0"><a name="line22" />  22 # Note: The accuracy of unit conversions depends on the precision of the conversion factor.
</span><span class="inferred1"><a name="line23" />  23 # If you have more accurate estimates for particular conversion factors, please send them 
</span><span class="inferred0"><a name="line24" />  24 # to me and I will incorporate them into the next release.  It is also incumbent on the end-user
</span><span class="inferred1"><a name="line25" />  25 # to ensure that the accuracy of any conversions is sufficient for their intended application.
</span><span class="inferred0"><a name="line26" />  26 #
</span><span class="inferred1"><a name="line27" />  27 # While there are a large number of unit specified in the base package, 
</span><span class="inferred0"><a name="line28" />  28 # there are also a large number of units that are not included.
</span><span class="inferred1"><a name="line29" />  29 # This package covers nearly all SI, Imperial, and units commonly used
</span><span class="inferred0"><a name="line30" />  30 # in the United States. If your favorite units are not listed here, send me an email
</span><span class="inferred1"><a name="line31" />  31 #
</span><span class="inferred0"><a name="line32" />  32 # To add / override a unit definition, add a code block like this..
</span><span class="inferred1"><a name="line33" />  33 #
</span><span class="inferred0"><a name="line34" />  34 #  class Unit &lt; Numeric
</span><span class="inferred1"><a name="line35" />  35 #   UNIT_DEFINITIONS = {
</span><span class="inferred0"><a name="line36" />  36 #    &lt;name&gt;'  =&gt; [%w{prefered_name synonyms}, conversion_to_base, :classification, %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;numerator&gt;} , %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;denominator&gt;} ]
</span><span class="inferred1"><a name="line37" />  37 #    }
</span><span class="inferred0"><a name="line38" />  38 #  end
</span><span class="inferred1"><a name="line39" />  39 #  Unit.setup
</span><span class="marked0"><a name="line40" />  40 class Unit &lt; Numeric
</span><span class="marked1"><a name="line41" />  41   require 'units'
</span><span class="inferred0"><a name="line42" />  42   # pre-generate hashes from unit definitions for performance.  
</span><span class="marked1"><a name="line43" />  43   @@USER_DEFINITIONS = {}
</span><span class="marked0"><a name="line44" />  44   @@PREFIX_VALUES = {}
</span><span class="marked1"><a name="line45" />  45   @@PREFIX_MAP = {}
</span><span class="marked0"><a name="line46" />  46   @@UNIT_MAP = {}
</span><span class="marked1"><a name="line47" />  47   @@UNIT_VALUES = {}
</span><span class="marked0"><a name="line48" />  48   @@OUTPUT_MAP = {}
</span><span class="marked1"><a name="line49" />  49   @@UNIT_VECTORS = {}
</span><span class="inferred0"><a name="line50" />  50 
</span><span class="marked1"><a name="line51" />  51   def self.setup
</span><span class="marked0"><a name="line52" />  52     (UNIT_DEFINITIONS.merge!(@@USER_DEFINITIONS)).each do |key, value|
</span><span class="marked1"><a name="line53" />  53       if value[2] == :prefix then
</span><span class="marked0"><a name="line54" />  54         @@PREFIX_VALUES[Regexp.escape(key)]=value[1]
</span><span class="marked1"><a name="line55" />  55         value[0].each {|x| @@PREFIX_MAP[Regexp.escape(x)]=key}    
</span><span class="inferred0"><a name="line56" />  56       else
</span><span class="marked1"><a name="line57" />  57         @@UNIT_VALUES[Regexp.escape(key)]={}
</span><span class="marked0"><a name="line58" />  58         @@UNIT_VALUES[Regexp.escape(key)][:scalar]=value[1]
</span><span class="marked1"><a name="line59" />  59         @@UNIT_VALUES[Regexp.escape(key)][:numerator]=value[3] if value[3]
</span><span class="marked0"><a name="line60" />  60         @@UNIT_VALUES[Regexp.escape(key)][:denominator]=value[4] if value[4]
</span><span class="marked1"><a name="line61" />  61         value[0].each {|x| @@UNIT_MAP[Regexp.escape(x)]=key}
</span><span class="marked0"><a name="line62" />  62         @@UNIT_VECTORS[value[2]] = [] unless @@UNIT_VECTORS[value[2]]
</span><span class="marked1"><a name="line63" />  63         @@UNIT_VECTORS[value[2]] = @@UNIT_VECTORS[value[2]]+[Regexp.escape(key)]
</span><span class="inferred0"><a name="line64" />  64       end
</span><span class="marked1"><a name="line65" />  65       @@OUTPUT_MAP[Regexp.escape(key)]=value[0][0]
</span><span class="inferred0"><a name="line66" />  66     end
</span><span class="marked1"><a name="line67" />  67     @@PREFIX_REGEX = @@PREFIX_MAP.keys.sort_by {|prefix| prefix.length}.reverse.join('|')
</span><span class="marked0"><a name="line68" />  68     @@UNIT_REGEX = @@UNIT_MAP.keys.sort_by {|unit| unit.length}.reverse.join('|')
</span><span class="inferred1"><a name="line69" />  69   end
</span><span class="inferred0"><a name="line70" />  70   
</span><span class="marked1"><a name="line71" />  71   self.setup
</span><span class="inferred0"><a name="line72" />  72   
</span><span class="marked1"><a name="line73" />  73   include Comparable
</span><span class="marked0"><a name="line74" />  74   attr_accessor :scalar, :numerator, :denominator, :signature, :base_scalar
</span><span class="inferred1"><a name="line75" />  75 
</span><span class="marked0"><a name="line76" />  76   def to_yaml_properties
</span><span class="marked1"><a name="line77" />  77     %w{@scalar @numerator @denominator @signature @base_scalar}
</span><span class="marked0"><a name="line78" />  78   end
</span><span class="inferred1"><a name="line79" />  79   
</span><span class="inferred0"><a name="line80" />  80   # basically a copy of the basic to_yaml.  Needed because otherwise it ends up coercing the object to a string
</span><span class="inferred1"><a name="line81" />  81   # before YAML'izing it.
</span><span class="marked0"><a name="line82" />  82   def to_yaml( opts = {} )
</span><span class="marked1"><a name="line83" />  83     YAML::quick_emit( object_id, opts ) do |out|
</span><span class="marked0"><a name="line84" />  84       out.map( taguri, to_yaml_style ) do |map|
</span><span class="marked1"><a name="line85" />  85         to_yaml_properties.each do |m|
</span><span class="marked0"><a name="line86" />  86           map.add( m[1..-1], instance_variable_get( m ) )
</span><span class="inferred1"><a name="line87" />  87         end
</span><span class="inferred0"><a name="line88" />  88       end
</span><span class="inferred1"><a name="line89" />  89     end
</span><span class="marked0"><a name="line90" />  90   end
</span><span class="inferred1"><a name="line91" />  91   
</span><span class="inferred0"><a name="line92" />  92   # Create a new Unit object.  Can be initialized using a string, or a hash
</span><span class="inferred1"><a name="line93" />  93   # Valid formats include:
</span><span class="inferred0"><a name="line94" />  94   #  &quot;5.6 kg*m/s^2&quot;
</span><span class="inferred1"><a name="line95" />  95   #  &quot;5.6 kg*m*s^-2&quot;
</span><span class="inferred0"><a name="line96" />  96   #  &quot;5.6 kilogram*meter*second^-2&quot;
</span><span class="inferred1"><a name="line97" />  97   #  &quot;2.2 kPa&quot;
</span><span class="inferred0"><a name="line98" />  98   #  &quot;37 degC&quot;
</span><span class="inferred1"><a name="line99" />  99   #  &quot;1&quot;  -- creates a unitless constant with value 1
</span><span class="inferred0"><a name="line100" /> 100   #  &quot;GPa&quot;  -- creates a unit with scalar 1 with units 'GPa'
</span><span class="inferred1"><a name="line101" /> 101   #  6'4&quot;  -- recognized as 6 feet + 4 inches 
</span><span class="inferred0"><a name="line102" /> 102   #  8 lbs 8 oz -- recognized as 8 lbs + 8 ounces
</span><span class="inferred1"><a name="line103" /> 103   #
</span><span class="marked0"><a name="line104" /> 104   def initialize(options)    
</span><span class="marked1"><a name="line105" /> 105     case options
</span><span class="marked0"><a name="line106" /> 106     when String: parse(options)
</span><span class="marked1"><a name="line107" /> 107     when Hash:
</span><span class="marked0"><a name="line108" /> 108       @scalar = options[:scalar] || 1
</span><span class="marked1"><a name="line109" /> 109       @numerator = options[:numerator] || [&quot;&lt;1&gt;&quot;]
</span><span class="marked0"><a name="line110" /> 110       @denominator = options[:denominator] || []
</span><span class="marked1"><a name="line111" /> 111     when Array: 
</span><span class="marked0"><a name="line112" /> 112       parse(&quot;#{options[0]} #{options[1]}/#{options[2]}&quot;)
</span><span class="marked1"><a name="line113" /> 113     when Numeric:
</span><span class="marked0"><a name="line114" /> 114       @scalar = options
</span><span class="marked1"><a name="line115" /> 115       @numerator = @denominator = ['&lt;1&gt;']
</span><span class="marked0"><a name="line116" /> 116     when Time:
</span><span class="marked1"><a name="line117" /> 117       @scalar = options.to_f
</span><span class="marked0"><a name="line118" /> 118       @numerator = ['&lt;second&gt;']
</span><span class="marked1"><a name="line119" /> 119       @denominator = ['&lt;1&gt;']
</span><span class="inferred0"><a name="line120" /> 120     else
</span><span class="marked1"><a name="line121" /> 121       raise ArgumentError, &quot;Invalid Unit Format&quot;
</span><span class="inferred0"><a name="line122" /> 122     end
</span><span class="marked1"><a name="line123" /> 123     self.update_base_scalar
</span><span class="marked0"><a name="line124" /> 124     self.replace_temperature
</span><span class="marked1"><a name="line125" /> 125     self.freeze
</span><span class="inferred0"><a name="line126" /> 126   end
</span><span class="inferred1"><a name="line127" /> 127   
</span><span class="marked0"><a name="line128" /> 128   def to_unit
</span><span class="marked1"><a name="line129" /> 129     self
</span><span class="marked0"><a name="line130" /> 130   end
</span><span class="marked1"><a name="line131" /> 131   alias :unit :to_unit
</span><span class="inferred0"><a name="line132" /> 132   
</span><span class="inferred1"><a name="line133" /> 133   # Returns 'true' if the Unit is represented in base units
</span><span class="marked0"><a name="line134" /> 134   def is_base?
</span><span class="marked1"><a name="line135" /> 135     return true if @signature == 400 &amp;&amp; @numerator.size == 1 &amp;&amp; @numerator[0] =~ /(celcius|kelvin|farenheit|rankine)/
</span><span class="marked0"><a name="line136" /> 136     n = @numerator + @denominator
</span><span class="marked1"><a name="line137" /> 137     n.compact.each do |x|
</span><span class="inferred0"><a name="line138" /> 138       return false unless x == '&lt;1&gt;' || 
</span><span class="inferred1"><a name="line139" /> 139         (@@UNIT_VALUES[Regexp.escape(x)] &amp;&amp;  
</span><span class="marked0"><a name="line140" /> 140           @@UNIT_VALUES[Regexp.escape(x)][:denominator].nil? &amp;&amp; 
</span><span class="marked1"><a name="line141" /> 141             @@UNIT_VALUES[Regexp.escape(x)][:numerator].include?(Regexp.escape(x)))
</span><span class="inferred0"><a name="line142" /> 142     end
</span><span class="marked1"><a name="line143" /> 143     return true
</span><span class="inferred0"><a name="line144" /> 144   end  
</span><span class="inferred1"><a name="line145" /> 145   
</span><span class="inferred0"><a name="line146" /> 146   #convert to base SI units
</span><span class="marked1"><a name="line147" /> 147   def to_base
</span><span class="marked0"><a name="line148" /> 148     return self if self.is_base?
</span><span class="inferred1"><a name="line149" /> 149 #    return self.to('degK') if self.units =~ /temp(C|K|F|R)/ 
</span><span class="marked0"><a name="line150" /> 150     num = []
</span><span class="marked1"><a name="line151" /> 151     den = []
</span><span class="marked0"><a name="line152" /> 152     q = @scalar
</span><span class="marked1"><a name="line153" /> 153     @numerator.compact.each do |unit|
</span><span class="marked0"><a name="line154" /> 154         if @@PREFIX_VALUES[Regexp.escape(unit)]
</span><span class="marked1"><a name="line155" /> 155           q *= @@PREFIX_VALUES[Regexp.escape(unit)]
</span><span class="inferred0"><a name="line156" /> 156         else
</span><span class="marked1"><a name="line157" /> 157           q *= @@UNIT_VALUES[Regexp.escape(unit)][:scalar] if @@UNIT_VALUES[Regexp.escape(unit)]
</span><span class="marked0"><a name="line158" /> 158           num &lt;&lt; @@UNIT_VALUES[Regexp.escape(unit)][:numerator] if @@UNIT_VALUES[Regexp.escape(unit)] &amp;&amp; @@UNIT_VALUES[Regexp.escape(unit)][:numerator]
</span><span class="marked1"><a name="line159" /> 159           den &lt;&lt; @@UNIT_VALUES[Regexp.escape(unit)][:denominator] if @@UNIT_VALUES[Regexp.escape(unit)] &amp;&amp; @@UNIT_VALUES[Regexp.escape(unit)][:denominator]
</span><span class="inferred0"><a name="line160" /> 160         end
</span><span class="inferred1"><a name="line161" /> 161     end
</span><span class="marked0"><a name="line162" /> 162     @denominator.compact.each do |unit|
</span><span class="marked1"><a name="line163" /> 163         if @@PREFIX_VALUES[Regexp.escape(unit)]
</span><span class="marked0"><a name="line164" /> 164           q /= @@PREFIX_VALUES[Regexp.escape(unit)]
</span><span class="inferred1"><a name="line165" /> 165         else
</span><span class="marked0"><a name="line166" /> 166           q /= @@UNIT_VALUES[Regexp.escape(unit)][:scalar] if @@UNIT_VALUES[Regexp.escape(unit)]
</span><span class="marked1"><a name="line167" /> 167           den &lt;&lt; @@UNIT_VALUES[Regexp.escape(unit)][:numerator] if @@UNIT_VALUES[Regexp.escape(unit)] &amp;&amp; @@UNIT_VALUES[Regexp.escape(unit)][:numerator]
</span><span class="marked0"><a name="line168" /> 168           num &lt;&lt; @@UNIT_VALUES[Regexp.escape(unit)][:denominator] if @@UNIT_VALUES[Regexp.escape(unit)] &amp;&amp; @@UNIT_VALUES[Regexp.escape(unit)][:denominator]
</span><span class="inferred1"><a name="line169" /> 169         end
</span><span class="inferred0"><a name="line170" /> 170     end
</span><span class="inferred1"><a name="line171" /> 171     
</span><span class="marked0"><a name="line172" /> 172     num = num.flatten.compact
</span><span class="marked1"><a name="line173" /> 173     den = den.flatten.compact
</span><span class="marked0"><a name="line174" /> 174     num = ['&lt;1&gt;'] if num.empty?
</span><span class="inferred1"><a name="line175" /> 175    
</span><span class="marked0"><a name="line176" /> 176     Unit.new(Unit.eliminate_terms(q,num,den))
</span><span class="inferred1"><a name="line177" /> 177   end
</span><span class="inferred0"><a name="line178" /> 178   
</span><span class="inferred1"><a name="line179" /> 179   # Generate human readable output.
</span><span class="inferred0"><a name="line180" /> 180   # If the name of a unit is passed, the scalar will first be converted to the target unit before output.
</span><span class="inferred1"><a name="line181" /> 181   # some named conversions are available
</span><span class="inferred0"><a name="line182" /> 182   #
</span><span class="inferred1"><a name="line183" /> 183   #  :ft - outputs in feet and inches (e.g., 6'4&quot;)
</span><span class="inferred0"><a name="line184" /> 184   #  :lbs - outputs in pounds and ounces (e.g, 8 lbs, 8 oz)
</span><span class="marked1"><a name="line185" /> 185   def to_s(target_units=nil)
</span><span class="marked0"><a name="line186" /> 186     case target_units
</span><span class="marked1"><a name="line187" /> 187     when :ft:
</span><span class="marked0"><a name="line188" /> 188       inches = self.to(&quot;in&quot;).scalar
</span><span class="marked1"><a name="line189" /> 189       &quot;#{(inches / 12).truncate}\'#{(inches % 12).round}\&quot;&quot;
</span><span class="marked0"><a name="line190" /> 190     when :lbs:
</span><span class="marked1"><a name="line191" /> 191       ounces = self.to(&quot;oz&quot;).scalar
</span><span class="marked0"><a name="line192" /> 192       &quot;#{(ounces / 16).truncate} lbs, #{(ounces % 16).round} oz&quot;
</span><span class="marked1"><a name="line193" /> 193     when String
</span><span class="marked0"><a name="line194" /> 194       begin #first try a standard format string
</span><span class="marked1"><a name="line195" /> 195         target_units =~ /(%[\w\d#+-.]*)*\s*(.+)*/
</span><span class="marked0"><a name="line196" /> 196         return self.to($2).to_s($1) if $2
</span><span class="marked1"><a name="line197" /> 197         &quot;#{($1 || '%g') % @scalar || 0} #{self.units}&quot;.strip
</span><span class="inferred0"><a name="line198" /> 198       rescue #if that is malformed, try a time string
</span><span class="marked1"><a name="line199" /> 199         return (Time.gm(0) + self).strftime(target_units)
</span><span class="inferred0"><a name="line200" /> 200       end
</span><span class="inferred1"><a name="line201" /> 201     else
</span><span class="marked0"><a name="line202" /> 202       &quot;#{'%g' % @scalar} #{self.units}&quot;.strip
</span><span class="inferred1"><a name="line203" /> 203     end    
</span><span class="marked0"><a name="line204" /> 204   end
</span><span class="inferred1"><a name="line205" /> 205   
</span><span class="marked0"><a name="line206" /> 206   def inspect(option=nil)
</span><span class="marked1"><a name="line207" /> 207     return super() if option == :dump
</span><span class="marked0"><a name="line208" /> 208     self.to_s
</span><span class="inferred1"><a name="line209" /> 209   end
</span><span class="inferred0"><a name="line210" /> 210   
</span><span class="inferred1"><a name="line211" /> 211   # returns true if no associated units
</span><span class="marked0"><a name="line212" /> 212   def unitless?
</span><span class="marked1"><a name="line213" /> 213     (@numerator == ['&lt;1&gt;'] &amp;&amp; @denominator == ['&lt;1&gt;'])
</span><span class="marked0"><a name="line214" /> 214   end
</span><span class="inferred1"><a name="line215" /> 215   
</span><span class="inferred0"><a name="line216" /> 216   # Compare two Unit objects. Throws an exception if they are not of compatible types.
</span><span class="inferred1"><a name="line217" /> 217   # Comparisons are done based on the value of the unit in base SI units.
</span><span class="marked0"><a name="line218" /> 218   def &lt;=&gt;(other)
</span><span class="marked1"><a name="line219" /> 219     case other
</span><span class="marked0"><a name="line220" /> 220     when Unit:
</span><span class="marked1"><a name="line221" /> 221       raise ArgumentError, &quot;Incompatible Units&quot; unless self =~ other
</span><span class="marked0"><a name="line222" /> 222       self.base_scalar &lt;=&gt; other.base_scalar
</span><span class="inferred1"><a name="line223" /> 223     else
</span><span class="marked0"><a name="line224" /> 224       x,y = coerce(other)
</span><span class="marked1"><a name="line225" /> 225       x &lt;=&gt; y
</span><span class="inferred0"><a name="line226" /> 226     end
</span><span class="marked1"><a name="line227" /> 227   end
</span><span class="inferred0"><a name="line228" /> 228   
</span><span class="inferred1"><a name="line229" /> 229   # check to see if units are compatible, but not the scalar part
</span><span class="inferred0"><a name="line230" /> 230   # this check is done by comparing signatures for performance reasons
</span><span class="inferred1"><a name="line231" /> 231   # if passed a string, it will create a unit object with the string and then do the comparison
</span><span class="inferred0"><a name="line232" /> 232   # this permits a syntax like:  
</span><span class="inferred1"><a name="line233" /> 233   #  unit =~ &quot;mm&quot;
</span><span class="inferred0"><a name="line234" /> 234   # if you want to do a regexp on the unit string do this ...
</span><span class="inferred1"><a name="line235" /> 235   #  unit.units =~ /regexp/
</span><span class="marked0"><a name="line236" /> 236   def =~(other)
</span><span class="marked1"><a name="line237" /> 237     case other
</span><span class="marked0"><a name="line238" /> 238     when Unit : self.signature == other.signature
</span><span class="inferred1"><a name="line239" /> 239     else
</span><span class="marked0"><a name="line240" /> 240       x,y = coerce(other)
</span><span class="marked1"><a name="line241" /> 241       x =~ y
</span><span class="inferred0"><a name="line242" /> 242     end 
</span><span class="marked1"><a name="line243" /> 243   end
</span><span class="inferred0"><a name="line244" /> 244   
</span><span class="marked1"><a name="line245" /> 245   alias :compatible? :=~
</span><span class="marked0"><a name="line246" /> 246   alias :compatible_with? :=~
</span><span class="inferred1"><a name="line247" /> 247   
</span><span class="inferred0"><a name="line248" /> 248   # Compare two units.  Returns true if quantities and units match
</span><span class="inferred1"><a name="line249" /> 249   #
</span><span class="inferred0"><a name="line250" /> 250   # Unit(&quot;100 cm&quot;) === Unit(&quot;100 cm&quot;)   # =&gt; true
</span><span class="inferred1"><a name="line251" /> 251   # Unit(&quot;100 cm&quot;) === Unit(&quot;1 m&quot;)      # =&gt; false
</span><span class="marked0"><a name="line252" /> 252   def ===(other)
</span><span class="marked1"><a name="line253" /> 253     case other
</span><span class="marked0"><a name="line254" /> 254     when Unit: (self.scalar == other.scalar) &amp;&amp; (self.units == other.units)
</span><span class="inferred1"><a name="line255" /> 255     else
</span><span class="marked0"><a name="line256" /> 256       x,y = coerce(other)
</span><span class="marked1"><a name="line257" /> 257       x === y
</span><span class="inferred0"><a name="line258" /> 258     end
</span><span class="marked1"><a name="line259" /> 259   end
</span><span class="inferred0"><a name="line260" /> 260   
</span><span class="marked1"><a name="line261" /> 261   alias :same? :===
</span><span class="marked0"><a name="line262" /> 262   alias :same_as? :===
</span><span class="inferred1"><a name="line263" /> 263   
</span><span class="inferred0"><a name="line264" /> 264   # Add two units together.  Result is same units as receiver and scalar and base_scalar are updated appropriately
</span><span class="inferred1"><a name="line265" /> 265   # throws an exception if the units are not compatible.
</span><span class="marked0"><a name="line266" /> 266   def +(other)   
</span><span class="marked1"><a name="line267" /> 267     if Unit === other 
</span><span class="marked0"><a name="line268" /> 268       if self =~ other then
</span><span class="marked1"><a name="line269" /> 269         a = self.to_base
</span><span class="marked0"><a name="line270" /> 270         b = other.to_base
</span><span class="marked1"><a name="line271" /> 271         Unit.new(:scalar=&gt;(a.scalar + b.scalar), :numerator=&gt;a.numerator, :denominator=&gt;b.denominator).to(self)
</span><span class="inferred0"><a name="line272" /> 272       else
</span><span class="marked1"><a name="line273" /> 273          raise ArgumentError,  &quot;Incompatible Units&quot;
</span><span class="inferred0"><a name="line274" /> 274       end
</span><span class="marked1"><a name="line275" /> 275     elsif Time === other
</span><span class="marked0"><a name="line276" /> 276       other + self
</span><span class="inferred1"><a name="line277" /> 277     else
</span><span class="marked0"><a name="line278" /> 278         x,y = coerce(other)
</span><span class="marked1"><a name="line279" /> 279         y + x
</span><span class="inferred0"><a name="line280" /> 280     end
</span><span class="marked1"><a name="line281" /> 281   end
</span><span class="inferred0"><a name="line282" /> 282   
</span><span class="inferred1"><a name="line283" /> 283   # Subtract two units. Result is same units as receiver and scalar and base_scalar are updated appropriately
</span><span class="inferred0"><a name="line284" /> 284   # throws an exception if the units are not compatible.
</span><span class="marked1"><a name="line285" /> 285   def -(other)
</span><span class="marked0"><a name="line286" /> 286     if Unit === other 
</span><span class="marked1"><a name="line287" /> 287       if self =~ other then
</span><span class="marked0"><a name="line288" /> 288         a = self.to_base
</span><span class="marked1"><a name="line289" /> 289         b = other.to_base
</span><span class="marked0"><a name="line290" /> 290         Unit.new(:scalar=&gt;(a.scalar - b.scalar), :numerator=&gt;a.numerator, :denominator=&gt;b.denominator).to(self)
</span><span class="inferred1"><a name="line291" /> 291       else
</span><span class="marked0"><a name="line292" /> 292          raise ArgumentError,  &quot;Incompatible Units&quot;
</span><span class="inferred1"><a name="line293" /> 293       end
</span><span class="marked0"><a name="line294" /> 294     elsif Time === other
</span><span class="marked1"><a name="line295" /> 295       other - self
</span><span class="inferred0"><a name="line296" /> 296     else
</span><span class="marked1"><a name="line297" /> 297         x,y = coerce(other)
</span><span class="marked0"><a name="line298" /> 298         x - y
</span><span class="inferred1"><a name="line299" /> 299     end
</span><span class="marked0"><a name="line300" /> 300   end
</span><span class="inferred1"><a name="line301" /> 301   
</span><span class="inferred0"><a name="line302" /> 302   # Multiply two units.
</span><span class="marked1"><a name="line303" /> 303   def *(other)
</span><span class="marked0"><a name="line304" /> 304     if Unit === other
</span><span class="marked1"><a name="line305" /> 305       Unit.new(Unit.eliminate_terms(@scalar*other.scalar, @numerator + other.numerator ,@denominator + other.denominator))      
</span><span class="inferred0"><a name="line306" /> 306     else
</span><span class="marked1"><a name="line307" /> 307       x,y = coerce(other)
</span><span class="marked0"><a name="line308" /> 308       x * y
</span><span class="inferred1"><a name="line309" /> 309     end
</span><span class="marked0"><a name="line310" /> 310   end
</span><span class="inferred1"><a name="line311" /> 311   
</span><span class="inferred0"><a name="line312" /> 312   # Divide two units.
</span><span class="inferred1"><a name="line313" /> 313   # Throws an exception if divisor is 0
</span><span class="marked0"><a name="line314" /> 314   def /(other)
</span><span class="marked1"><a name="line315" /> 315     if Unit === other
</span><span class="marked0"><a name="line316" /> 316       raise ZeroDivisionError if other.zero?
</span><span class="marked1"><a name="line317" /> 317       Unit.new(Unit.eliminate_terms(@scalar/other.scalar, @numerator + other.denominator ,@denominator + other.numerator))      
</span><span class="inferred0"><a name="line318" /> 318     else
</span><span class="marked1"><a name="line319" /> 319       x,y = coerce(other)
</span><span class="marked0"><a name="line320" /> 320       y / x
</span><span class="inferred1"><a name="line321" /> 321     end
</span><span class="marked0"><a name="line322" /> 322   end
</span><span class="inferred1"><a name="line323" /> 323     
</span><span class="inferred0"><a name="line324" /> 324   # Exponentiate.  Only takes integer powers. 
</span><span class="inferred1"><a name="line325" /> 325   # Note that anything raised to the power of 0 results in a Unit object with a scalar of 1, and no units.
</span><span class="inferred0"><a name="line326" /> 326   # Throws an exception if exponent is not an integer.
</span><span class="inferred1"><a name="line327" /> 327   # Ideally this routine should accept a float for the exponent
</span><span class="inferred0"><a name="line328" /> 328   # It should then convert the float to a rational and raise the unit by the numerator and root it by the denominator
</span><span class="inferred1"><a name="line329" /> 329   # but, sadly, floats can't be converted to rationals.
</span><span class="inferred0"><a name="line330" /> 330   #
</span><span class="inferred1"><a name="line331" /> 331   # For now, if a rational is passed in, it will be used, otherwise we are stuck with integers and certain floats &lt; 1
</span><span class="marked0"><a name="line332" /> 332   def **(other)
</span><span class="marked1"><a name="line333" /> 333     if Numeric === other
</span><span class="marked0"><a name="line334" /> 334       return Unit(&quot;1&quot;) if other.zero?
</span><span class="marked1"><a name="line335" /> 335       return self if other == 1
</span><span class="marked0"><a name="line336" /> 336       return self.inverse if other == -1
</span><span class="inferred1"><a name="line337" /> 337     end
</span><span class="marked0"><a name="line338" /> 338     case other
</span><span class="marked1"><a name="line339" /> 339     when Rational:
</span><span class="marked0"><a name="line340" /> 340       self.power(other.numerator).root(other.denominator)
</span><span class="marked1"><a name="line341" /> 341     when Integer:
</span><span class="marked0"><a name="line342" /> 342       self.power(other)
</span><span class="marked1"><a name="line343" /> 343     when Float:
</span><span class="marked0"><a name="line344" /> 344       return self**(other.to_i) if other == other.to_i
</span><span class="marked1"><a name="line345" /> 345       valid = (1..9).map {|x| 1/x}
</span><span class="marked0"><a name="line346" /> 346       raise ArgumentError, &quot;Not a n-th root (1..9), use 1/n&quot; unless valid.include? other.abs
</span><span class="marked1"><a name="line347" /> 347       self.root((1/other).to_int)
</span><span class="inferred0"><a name="line348" /> 348     else
</span><span class="marked1"><a name="line349" /> 349       raise ArgumentError, &quot;Invalid Exponent&quot;
</span><span class="inferred0"><a name="line350" /> 350     end
</span><span class="inferred1"><a name="line351" /> 351   end
</span><span class="inferred0"><a name="line352" /> 352   
</span><span class="inferred1"><a name="line353" /> 353 
</span><span class="inferred0"><a name="line354" /> 354   # returns the unit raised to the n-th power.  Integers only
</span><span class="marked1"><a name="line355" /> 355   def power(n)
</span><span class="marked0"><a name="line356" /> 356     raise ArgumentError, &quot;Can only use Integer exponenents&quot; unless Integer === n
</span><span class="marked1"><a name="line357" /> 357     return self if n == 1
</span><span class="marked0"><a name="line358" /> 358     return Unit(&quot;1&quot;) if n == 0
</span><span class="marked1"><a name="line359" /> 359     return self.inverse if n == -1
</span><span class="marked0"><a name="line360" /> 360     if n &gt; 0 then 
</span><span class="marked1"><a name="line361" /> 361       (1..n.to_i).inject(Unit.new(&quot;1&quot;)) {|product, x| product * self}
</span><span class="inferred0"><a name="line362" /> 362     else
</span><span class="marked1"><a name="line363" /> 363       (1..-n.to_i).inject(Unit.new(&quot;1&quot;)) {|product, x| product / self}
</span><span class="inferred0"><a name="line364" /> 364     end
</span><span class="inferred1"><a name="line365" /> 365   end
</span><span class="inferred0"><a name="line366" /> 366   
</span><span class="inferred1"><a name="line367" /> 367   # Calculates the n-th root of a unit, where n = (1..9)
</span><span class="inferred0"><a name="line368" /> 368   # if n &lt; 0, returns 1/unit^(1/n)
</span><span class="marked1"><a name="line369" /> 369   def root(n)
</span><span class="marked0"><a name="line370" /> 370     raise ArgumentError, &quot;Exponent must an Integer&quot; unless Integer === n
</span><span class="marked1"><a name="line371" /> 371     raise ArgumentError, &quot;0th root undefined&quot; if n == 0
</span><span class="marked0"><a name="line372" /> 372     return self if n == 1
</span><span class="marked1"><a name="line373" /> 373     return self.root(n.abs).inverse if n &lt; 0
</span><span class="inferred0"><a name="line374" /> 374     
</span><span class="marked1"><a name="line375" /> 375     vec = self.unit_signature_vector
</span><span class="marked0"><a name="line376" /> 376     vec=vec.map {|x| x % n}      
</span><span class="marked1"><a name="line377" /> 377     raise ArgumentError, &quot;Illegal root&quot; unless vec.max == 0
</span><span class="marked0"><a name="line378" /> 378     num = @numerator.clone
</span><span class="marked1"><a name="line379" /> 379     den = @denominator.clone
</span><span class="inferred0"><a name="line380" /> 380       
</span><span class="marked1"><a name="line381" /> 381     @numerator.uniq.each do |item|
</span><span class="marked0"><a name="line382" /> 382       x = num.find_all {|i| i==item}.size
</span><span class="marked1"><a name="line383" /> 383       r = ((x/n)*(n-1)).to_int
</span><span class="marked0"><a name="line384" /> 384       r.times {|x| num.delete_at(num.index(item))}
</span><span class="inferred1"><a name="line385" /> 385     end
</span><span class="inferred0"><a name="line386" /> 386     
</span><span class="marked1"><a name="line387" /> 387     @denominator.uniq.each do |item|
</span><span class="marked0"><a name="line388" /> 388       x = den.find_all {|i| i==item}.size
</span><span class="marked1"><a name="line389" /> 389       r = ((x/n)*(n-1)).to_int
</span><span class="marked0"><a name="line390" /> 390       r.times {|x| den.delete_at(den.index(item))}
</span><span class="inferred1"><a name="line391" /> 391     end
</span><span class="marked0"><a name="line392" /> 392     q = @scalar**(1/n)    
</span><span class="marked1"><a name="line393" /> 393     Unit.new(:scalar=&gt;q,:numerator=&gt;num,:denominator=&gt;den)    
</span><span class="inferred0"><a name="line394" /> 394   end
</span><span class="inferred1"><a name="line395" /> 395   
</span><span class="inferred0"><a name="line396" /> 396   # returns inverse of Unit (1/unit)
</span><span class="marked1"><a name="line397" /> 397   def inverse
</span><span class="marked0"><a name="line398" /> 398     Unit(&quot;1&quot;) / self
</span><span class="marked1"><a name="line399" /> 399   end
</span><span class="inferred0"><a name="line400" /> 400   
</span><span class="inferred1"><a name="line401" /> 401   # convert to a specified unit string or to the same units as another Unit
</span><span class="inferred0"><a name="line402" /> 402   # 
</span><span class="inferred1"><a name="line403" /> 403   #  unit &gt;&gt; &quot;kg&quot;  will covert to kilograms
</span><span class="inferred0"><a name="line404" /> 404   #  unit1 &gt;&gt; unit2 converts to same units as unit2 object
</span><span class="inferred1"><a name="line405" /> 405   # 
</span><span class="inferred0"><a name="line406" /> 406   # To convert a Unit object to match another Unit object, use:
</span><span class="inferred1"><a name="line407" /> 407   #  unit1 &gt;&gt;= unit2
</span><span class="inferred0"><a name="line408" /> 408   # Throws an exception if the requested target units are incompatible with current Unit.
</span><span class="inferred1"><a name="line409" /> 409   #
</span><span class="inferred0"><a name="line410" /> 410   # Special handling for temperature conversions is supported.  If the Unit object is converted
</span><span class="inferred1"><a name="line411" /> 411   # from one temperature unit to another, the proper temperature offsets will be used.
</span><span class="inferred0"><a name="line412" /> 412   # Supports Kelvin, Celcius, Farenheit, and Rankine scales.
</span><span class="inferred1"><a name="line413" /> 413   #
</span><span class="inferred0"><a name="line414" /> 414   # Note that if temperature is part of a compound unit, the temperature will be treated as a differential
</span><span class="inferred1"><a name="line415" /> 415   # and the units will be scaled appropriately.
</span><span class="marked0"><a name="line416" /> 416   def to(other)
</span><span class="marked1"><a name="line417" /> 417     return self if other.nil? 
</span><span class="marked0"><a name="line418" /> 418     return self if TrueClass === other
</span><span class="marked1"><a name="line419" /> 419     return self if FalseClass === other
</span><span class="marked0"><a name="line420" /> 420     if (Unit === other &amp;&amp; other.units =~ /temp(K|C|R|F)/) || (String === other &amp;&amp; other =~ /temp(K|C|R|F)/) 
</span><span class="marked1"><a name="line421" /> 421       raise ArgumentError, &quot;Receiver is not a temperature unit&quot; unless self.signature==400 
</span><span class="marked0"><a name="line422" /> 422       return self.to_base.to(other) unless self.is_base?
</span><span class="marked1"><a name="line423" /> 423       start_unit = self.units
</span><span class="marked0"><a name="line424" /> 424       target_unit = other.units rescue other
</span><span class="marked1"><a name="line425" /> 425       q=case start_unit
</span><span class="marked0"><a name="line426" /> 426          when 'degC':
</span><span class="marked1"><a name="line427" /> 427           case target_unit
</span><span class="marked0"><a name="line428" /> 428             when 'tempC'  : @scalar
</span><span class="marked1"><a name="line429" /> 429             when 'tempK'  : @scalar + 273.15
</span><span class="marked0"><a name="line430" /> 430             when 'tempF'  : @scalar * (9.0/5.0) + 32.0
</span><span class="marked1"><a name="line431" /> 431             when 'tempR'  : @scalar * (9.0/5.0) + 491.67
</span><span class="inferred0"><a name="line432" /> 432           end
</span><span class="marked1"><a name="line433" /> 433         when 'degK':
</span><span class="marked0"><a name="line434" /> 434           case target_unit
</span><span class="marked1"><a name="line435" /> 435             when 'tempC'  : @scalar - 273.15
</span><span class="marked0"><a name="line436" /> 436             when 'tempK'  : @scalar 
</span><span class="marked1"><a name="line437" /> 437             when 'tempF'  : @scalar * (9.0/5.0) - 459.67
</span><span class="marked0"><a name="line438" /> 438             when 'tempR'  : @scalar * (9.0/5.0) 
</span><span class="inferred1"><a name="line439" /> 439           end
</span><span class="marked0"><a name="line440" /> 440         when 'degF':
</span><span class="marked1"><a name="line441" /> 441           case target_unit
</span><span class="marked0"><a name="line442" /> 442             when 'tempC'  : (@scalar-32)*(5.0/9.0)
</span><span class="marked1"><a name="line443" /> 443             when 'tempK'  : (@scalar+459.67)*(5.0/9.0)
</span><span class="marked0"><a name="line444" /> 444             when 'tempF'  : @scalar 
</span><span class="marked1"><a name="line445" /> 445             when 'tempR'  : @scalar  + 459.67
</span><span class="inferred0"><a name="line446" /> 446           end
</span><span class="marked1"><a name="line447" /> 447         when 'degR':
</span><span class="marked0"><a name="line448" /> 448           case target_unit
</span><span class="marked1"><a name="line449" /> 449             when 'tempC'  : @scalar*(5.0/9.0) -273.15
</span><span class="marked0"><a name="line450" /> 450             when 'tempK'  : @scalar*(5.0/9.0)
</span><span class="marked1"><a name="line451" /> 451             when 'tempF'  : @scalar - 459.67
</span><span class="marked0"><a name="line452" /> 452             when 'tempR'  : @scalar
</span><span class="inferred1"><a name="line453" /> 453           end
</span><span class="uncovered0"><a name="line454" /> 454         else
</span><span class="uncovered1"><a name="line455" /> 455           raise ArgumentError, &quot;Unknown temperature conversion requested #{self.numerator}&quot;
</span><span class="uncovered0"><a name="line456" /> 456       end
</span><span class="marked1"><a name="line457" /> 457       target_unit =~ /temp(C|K|F|R)/
</span><span class="marked0"><a name="line458" /> 458       Unit.new(&quot;#{q} deg#{$1}&quot;)
</span><span class="inferred1"><a name="line459" /> 459     else
</span><span class="marked0"><a name="line460" /> 460        case other
</span><span class="marked1"><a name="line461" /> 461           when Unit: 
</span><span class="marked0"><a name="line462" /> 462             return self if other.units == self.units
</span><span class="marked1"><a name="line463" /> 463             target = other
</span><span class="marked0"><a name="line464" /> 464           when String: target = Unit.new(other)
</span><span class="inferred1"><a name="line465" /> 465           else
</span><span class="marked0"><a name="line466" /> 466             raise ArgumentError, &quot;Unknown target units&quot;
</span><span class="inferred1"><a name="line467" /> 467         end
</span><span class="marked0"><a name="line468" /> 468       raise ArgumentError,  &quot;Incompatible Units&quot; unless self =~ target
</span><span class="marked1"><a name="line469" /> 469       one = @numerator.map {|x| @@PREFIX_VALUES[Regexp.escape(x)] ? @@PREFIX_VALUES[Regexp.escape(x)] : x}.map {|i| i.kind_of?(Numeric) ? i : @@UNIT_VALUES[Regexp.escape(i)][:scalar] }.compact
</span><span class="marked0"><a name="line470" /> 470       two = @denominator.map {|x| @@PREFIX_VALUES[Regexp.escape(x)] ? @@PREFIX_VALUES[Regexp.escape(x)] : x}.map {|i| i.kind_of?(Numeric) ? i : @@UNIT_VALUES[Regexp.escape(i)][:scalar] }.compact
</span><span class="marked1"><a name="line471" /> 471       v = one.inject(1) {|product,n| product*n} / two.inject(1) {|product,n| product*n}
</span><span class="marked0"><a name="line472" /> 472       one = target.numerator.map {|x| @@PREFIX_VALUES[Regexp.escape(x)] ? @@PREFIX_VALUES[Regexp.escape(x)] : x}.map {|x| x.kind_of?(Numeric) ? x : @@UNIT_VALUES[Regexp.escape(x)][:scalar] }.compact
</span><span class="marked1"><a name="line473" /> 473       two = target.denominator.map {|x| @@PREFIX_VALUES[Regexp.escape(x)] ? @@PREFIX_VALUES[Regexp.escape(x)] : x}.map {|x| x.kind_of?(Numeric) ? x : @@UNIT_VALUES[Regexp.escape(x)][:scalar] }.compact
</span><span class="marked0"><a name="line474" /> 474       y = one.inject(1) {|product,n| product*n} / two.inject(1) {|product,n| product*n}
</span><span class="marked1"><a name="line475" /> 475       q = @scalar * v/y
</span><span class="marked0"><a name="line476" /> 476       Unit.new(:scalar=&gt;q, :numerator=&gt;target.numerator, :denominator=&gt;target.denominator)
</span><span class="inferred1"><a name="line477" /> 477     end
</span><span class="inferred0"><a name="line478" /> 478   end  
</span><span class="marked1"><a name="line479" /> 479   alias :&gt;&gt; :to
</span><span class="marked0"><a name="line480" /> 480   alias :convert_to :to
</span><span class="inferred1"><a name="line481" /> 481     
</span><span class="inferred0"><a name="line482" /> 482   # Eliminates terms in the passed numerator and denominator.  Expands out prefixes and applies them to the 
</span><span class="inferred1"><a name="line483" /> 483   # scalar.  Returns a hash that can be used to initialize a new Unit object. 
</span><span class="inferred0"><a name="line484" /> 484   # converts the unit back to a float if it is unitless
</span><span class="marked1"><a name="line485" /> 485   def to_f
</span><span class="marked0"><a name="line486" /> 486     return @scalar.to_f if self.unitless?
</span><span class="marked1"><a name="line487" /> 487     raise RuntimeError, &quot;Can't convert to float unless unitless.  Use Unit#scalar&quot;
</span><span class="inferred0"><a name="line488" /> 488   end
</span><span class="inferred1"><a name="line489" /> 489   
</span><span class="inferred0"><a name="line490" /> 490   # returns the 'unit' part of the Unit object without the scalar
</span><span class="marked1"><a name="line491" /> 491   def units
</span><span class="marked0"><a name="line492" /> 492     return &quot;&quot; if @numerator == [&quot;&lt;1&gt;&quot;] &amp;&amp; @denominator == [&quot;&lt;1&gt;&quot;]
</span><span class="marked1"><a name="line493" /> 493     output_n = []
</span><span class="marked0"><a name="line494" /> 494     output_d =[] 
</span><span class="marked1"><a name="line495" /> 495     num = @numerator.clone.compact
</span><span class="marked0"><a name="line496" /> 496     den = @denominator.clone.compact
</span><span class="marked1"><a name="line497" /> 497     if @numerator == [&quot;&lt;1&gt;&quot;]
</span><span class="marked0"><a name="line498" /> 498       output_n &lt;&lt; &quot;1&quot;
</span><span class="inferred1"><a name="line499" /> 499     else
</span><span class="marked0"><a name="line500" /> 500       num.each_with_index do |token,index|
</span><span class="marked1"><a name="line501" /> 501         if token &amp;&amp; @@PREFIX_VALUES[Regexp.escape(token)] then
</span><span class="marked0"><a name="line502" /> 502           output_n &lt;&lt; &quot;#{@@OUTPUT_MAP[Regexp.escape(token)]}#{@@OUTPUT_MAP[Regexp.escape(num[index+1])]}&quot;
</span><span class="marked1"><a name="line503" /> 503           num[index+1]=nil
</span><span class="inferred0"><a name="line504" /> 504         else
</span><span class="marked1"><a name="line505" /> 505           output_n &lt;&lt; &quot;#{@@OUTPUT_MAP[Regexp.escape(token)]}&quot; if token
</span><span class="inferred0"><a name="line506" /> 506         end
</span><span class="inferred1"><a name="line507" /> 507       end
</span><span class="inferred0"><a name="line508" /> 508     end
</span><span class="marked1"><a name="line509" /> 509     if @denominator == ['&lt;1&gt;']
</span><span class="marked0"><a name="line510" /> 510       output_d = ['1']
</span><span class="inferred1"><a name="line511" /> 511     else
</span><span class="marked0"><a name="line512" /> 512       den.each_with_index do |token,index|
</span><span class="marked1"><a name="line513" /> 513           if token &amp;&amp; @@PREFIX_VALUES[Regexp.escape(token)] then
</span><span class="uncovered0"><a name="line514" /> 514             output_d &lt;&lt; &quot;#{@@OUTPUT_MAP[Regexp.escape(token)]}#{@@OUTPUT_MAP[Regexp.escape(den[index+1])]}&quot;
</span><span class="uncovered1"><a name="line515" /> 515             den[index+1]=nil
</span><span class="inferred0"><a name="line516" /> 516           else
</span><span class="marked1"><a name="line517" /> 517             output_d &lt;&lt; &quot;#{@@OUTPUT_MAP[Regexp.escape(token)]}&quot; if token
</span><span class="inferred0"><a name="line518" /> 518           end
</span><span class="inferred1"><a name="line519" /> 519         end
</span><span class="inferred0"><a name="line520" /> 520     end
</span><span class="marked1"><a name="line521" /> 521     on = output_n.reject {|x| x.empty?}.map {|x| [x, output_n.find_all {|z| z==x}.size]}.uniq.map {|x| (&quot;#{x[0]}&quot;.strip+ (x[1] &gt; 1 ? &quot;^#{x[1]}&quot; : ''))}
</span><span class="marked0"><a name="line522" /> 522     od = output_d.reject {|x| x.empty?}.map {|x| [x, output_d.find_all {|z| z==x}.size]}.uniq.map {|x| (&quot;#{x[0]}&quot;.strip+ (x[1] &gt; 1 ? &quot;^#{x[1]}&quot; : ''))}
</span><span class="marked1"><a name="line523" /> 523     &quot;#{on.join('*')}#{od == ['1'] ? '': '/'+od.join('*')}&quot;.strip    
</span><span class="inferred0"><a name="line524" /> 524   end
</span><span class="inferred1"><a name="line525" /> 525   
</span><span class="inferred0"><a name="line526" /> 526   # negates the scalar of the Unit
</span><span class="marked1"><a name="line527" /> 527   def -@
</span><span class="marked0"><a name="line528" /> 528     Unit.new([-@scalar,@numerator,@denominator])    
</span><span class="marked1"><a name="line529" /> 529   end
</span><span class="inferred0"><a name="line530" /> 530   
</span><span class="inferred1"><a name="line531" /> 531   # returns abs of scalar, without the units
</span><span class="marked0"><a name="line532" /> 532   def abs
</span><span class="marked1"><a name="line533" /> 533     return @scalar.abs
</span><span class="marked0"><a name="line534" /> 534   end
</span><span class="inferred1"><a name="line535" /> 535   
</span><span class="marked0"><a name="line536" /> 536   def ceil
</span><span class="marked1"><a name="line537" /> 537     Unit.new([@scalar.ceil, @numerator, @denominator])    
</span><span class="marked0"><a name="line538" /> 538   end
</span><span class="inferred1"><a name="line539" /> 539   
</span><span class="marked0"><a name="line540" /> 540   def floor
</span><span class="marked1"><a name="line541" /> 541     Unit.new([@scalar.floor, @numerator, @denominator])    
</span><span class="marked0"><a name="line542" /> 542   end
</span><span class="inferred1"><a name="line543" /> 543 
</span><span class="inferred0"><a name="line544" /> 544   # changes internal scalar to an integer, but retains the units
</span><span class="inferred1"><a name="line545" /> 545   # if unitless, returns an int
</span><span class="marked0"><a name="line546" /> 546   def to_int
</span><span class="marked1"><a name="line547" /> 547     return @scalar.to_int if unitless?
</span><span class="marked0"><a name="line548" /> 548     Unit.new([@scalar.to_int, @numerator, @denominator])    
</span><span class="inferred1"><a name="line549" /> 549   end
</span><span class="inferred0"><a name="line550" /> 550   
</span><span class="inferred1"><a name="line551" /> 551   # Tries to make a Time object from current unit
</span><span class="marked0"><a name="line552" /> 552   def to_time
</span><span class="marked1"><a name="line553" /> 553     Time.at(self)
</span><span class="marked0"><a name="line554" /> 554   end
</span><span class="marked1"><a name="line555" /> 555   alias :time :to_time
</span><span class="marked0"><a name="line556" /> 556   alias :to_i :to_int
</span><span class="marked1"><a name="line557" /> 557   alias :truncate :to_int
</span><span class="inferred0"><a name="line558" /> 558   
</span><span class="marked1"><a name="line559" /> 559   def round
</span><span class="marked0"><a name="line560" /> 560     Unit.new([@scalar.round, @numerator, @denominator])    
</span><span class="marked1"><a name="line561" /> 561   end
</span><span class="inferred0"><a name="line562" /> 562    
</span><span class="inferred1"><a name="line563" /> 563   # true if scalar is zero
</span><span class="marked0"><a name="line564" /> 564   def zero?
</span><span class="marked1"><a name="line565" /> 565     return @scalar.zero?
</span><span class="marked0"><a name="line566" /> 566   end
</span><span class="inferred1"><a name="line567" /> 567   
</span><span class="inferred0"><a name="line568" /> 568   # '5 min'.unit.ago 
</span><span class="marked1"><a name="line569" /> 569   def ago
</span><span class="marked0"><a name="line570" /> 570     Time.now - self rescue DateTime.now - self
</span><span class="marked1"><a name="line571" /> 571   end
</span><span class="inferred0"><a name="line572" /> 572   
</span><span class="inferred1"><a name="line573" /> 573   # '5 min'.before(time)
</span><span class="marked0"><a name="line574" /> 574   def before(time_point = ::Time.now)
</span><span class="marked1"><a name="line575" /> 575     raise ArgumentError, &quot;Must specify a Time&quot; unless time_point
</span><span class="marked0"><a name="line576" /> 576     if String === time_point
</span><span class="marked1"><a name="line577" /> 577       time_point.time - self
</span><span class="inferred0"><a name="line578" /> 578     else
</span><span class="marked1"><a name="line579" /> 579       time_point - self
</span><span class="inferred0"><a name="line580" /> 580     end
</span><span class="inferred1"><a name="line581" /> 581   end
</span><span class="marked0"><a name="line582" /> 582   alias :before_now :before
</span><span class="inferred1"><a name="line583" /> 583   
</span><span class="inferred0"><a name="line584" /> 584   # 'min'.since(time)
</span><span class="marked1"><a name="line585" /> 585   def since(time_point = ::Time.now)
</span><span class="marked0"><a name="line586" /> 586     case time_point
</span><span class="marked1"><a name="line587" /> 587     when Time:      (Time.now - time_point).unit('s').to(self)
</span><span class="marked0"><a name="line588" /> 588     when DateTime:  (DateTime.now - time_point).unit('d').to(self)
</span><span class="marked1"><a name="line589" /> 589     when String:    
</span><span class="marked0"><a name="line590" /> 590       (DateTime.now - time_point.time(:context=&gt;:past)).unit('d').to(self)
</span><span class="inferred1"><a name="line591" /> 591     else
</span><span class="marked0"><a name="line592" /> 592       raise ArgumentError, &quot;Must specify a Time, DateTime, or String&quot; 
</span><span class="inferred1"><a name="line593" /> 593     end
</span><span class="marked0"><a name="line594" /> 594   end
</span><span class="inferred1"><a name="line595" /> 595   
</span><span class="inferred0"><a name="line596" /> 596   # 'min'.until(time)
</span><span class="marked1"><a name="line597" /> 597   def until(time_point = ::Time.now)
</span><span class="marked0"><a name="line598" /> 598     case time_point
</span><span class="marked1"><a name="line599" /> 599     when Time:      (time_point - Time.now).unit('s').to(self)
</span><span class="marked0"><a name="line600" /> 600     when DateTime:  (time_point - DateTime.now).unit('d').to(self)
</span><span class="marked1"><a name="line601" /> 601     when String:
</span><span class="marked0"><a name="line602" /> 602       r = (time_point.time(:context=&gt;:future) - DateTime.now)
</span><span class="marked1"><a name="line603" /> 603       Time === time_point.time ? r.unit('s').to(self) : r.unit('d').to(self)
</span><span class="inferred0"><a name="line604" /> 604     else
</span><span class="marked1"><a name="line605" /> 605       raise ArgumentError, &quot;Must specify a Time, DateTime, or String&quot; 
</span><span class="inferred0"><a name="line606" /> 606     end
</span><span class="marked1"><a name="line607" /> 607   end
</span><span class="inferred0"><a name="line608" /> 608   
</span><span class="inferred1"><a name="line609" /> 609   # '5 min'.from(time)
</span><span class="marked0"><a name="line610" /> 610   def from(time_point = ::Time.now)
</span><span class="marked1"><a name="line611" /> 611     raise ArgumentError, &quot;Must specify a Time&quot; unless time_point
</span><span class="marked0"><a name="line612" /> 612     if String === time_point
</span><span class="marked1"><a name="line613" /> 613       time_point.time + self
</span><span class="inferred0"><a name="line614" /> 614     else
</span><span class="marked1"><a name="line615" /> 615       time_point + self
</span><span class="inferred0"><a name="line616" /> 616     end
</span><span class="inferred1"><a name="line617" /> 617   end
</span><span class="marked0"><a name="line618" /> 618   alias :after :from
</span><span class="marked1"><a name="line619" /> 619   alias :from_now :from
</span><span class="inferred0"><a name="line620" /> 620       
</span><span class="marked1"><a name="line621" /> 621   def succ
</span><span class="marked0"><a name="line622" /> 622     raise ArgumentError, &quot;Non Integer Scalar&quot; unless @scalar == @scalar.to_i
</span><span class="marked1"><a name="line623" /> 623     q = @scalar.to_i.succ
</span><span class="marked0"><a name="line624" /> 624     Unit.new([q, @numerator, @denominator])
</span><span class="inferred1"><a name="line625" /> 625   end
</span><span class="inferred0"><a name="line626" /> 626       
</span><span class="inferred1"><a name="line627" /> 627   # Protected and Private Functions that should only be called from this class
</span><span class="marked0"><a name="line628" /> 628   protected
</span><span class="inferred1"><a name="line629" /> 629   
</span><span class="inferred0"><a name="line630" /> 630   
</span><span class="marked1"><a name="line631" /> 631   def update_base_scalar
</span><span class="marked0"><a name="line632" /> 632     if self.is_base?
</span><span class="marked1"><a name="line633" /> 633       @base_scalar = @scalar
</span><span class="marked0"><a name="line634" /> 634       @signature = unit_signature
</span><span class="inferred1"><a name="line635" /> 635     else
</span><span class="marked0"><a name="line636" /> 636       base = self.to_base
</span><span class="marked1"><a name="line637" /> 637       @base_scalar = base.scalar
</span><span class="marked0"><a name="line638" /> 638       @signature = base.signature
</span><span class="inferred1"><a name="line639" /> 639     end
</span><span class="marked0"><a name="line640" /> 640   end
</span><span class="inferred1"><a name="line641" /> 641   
</span><span class="inferred0"><a name="line642" /> 642   
</span><span class="marked1"><a name="line643" /> 643   def coerce(other)
</span><span class="marked0"><a name="line644" /> 644     case other
</span><span class="marked1"><a name="line645" /> 645     when Unit : [other, self]
</span><span class="inferred0"><a name="line646" /> 646     else 
</span><span class="marked1"><a name="line647" /> 647       [Unit.new(other), self]
</span><span class="inferred0"><a name="line648" /> 648     end
</span><span class="marked1"><a name="line649" /> 649   end
</span><span class="inferred0"><a name="line650" /> 650   
</span><span class="inferred1"><a name="line651" /> 651   
</span><span class="inferred0"><a name="line652" /> 652   # calculates the unit signature vector used by unit_signature
</span><span class="marked1"><a name="line653" /> 653   def unit_signature_vector
</span><span class="marked0"><a name="line654" /> 654       return self.to_base.unit_signature_vector unless self.is_base?
</span><span class="marked1"><a name="line655" /> 655       result = self
</span><span class="marked0"><a name="line656" /> 656       y = [:length, :time, :temperature, :mass, :current, :substance, :luminosity, :currency, :memory, :angle]
</span><span class="marked1"><a name="line657" /> 657       vector = Array.new(y.size,0)
</span><span class="marked0"><a name="line658" /> 658       y.each_with_index do |units,index|
</span><span class="marked1"><a name="line659" /> 659         vector[index] = result.numerator.compact.find_all {|x| @@UNIT_VECTORS[units].include? Regexp.escape(x)}.size
</span><span class="marked0"><a name="line660" /> 660         vector[index] -= result.denominator.compact.find_all {|x| @@UNIT_VECTORS[units].include? Regexp.escape(x)}.size  
</span><span class="inferred1"><a name="line661" /> 661       end
</span><span class="marked0"><a name="line662" /> 662       vector
</span><span class="inferred1"><a name="line663" /> 663   end
</span><span class="inferred0"><a name="line664" /> 664   
</span><span class="marked1"><a name="line665" /> 665   def replace_temperature
</span><span class="marked0"><a name="line666" /> 666     return self unless self.signature == 400 &amp;&amp; self.units =~ /temp(R|K|F|C)/
</span><span class="marked1"><a name="line667" /> 667     un = $1
</span><span class="marked0"><a name="line668" /> 668     target = self.units
</span><span class="marked1"><a name="line669" /> 669     @numerator = case un
</span><span class="marked0"><a name="line670" /> 670       when 'R' : ['&lt;rankine&gt;']
</span><span class="marked1"><a name="line671" /> 671       when 'C' : ['&lt;celcius&gt;']
</span><span class="marked0"><a name="line672" /> 672       when 'F' : ['&lt;farenheit&gt;']
</span><span class="marked1"><a name="line673" /> 673       when 'K' : ['&lt;kelvin&gt;']
</span><span class="inferred0"><a name="line674" /> 674     end
</span><span class="marked1"><a name="line675" /> 675     r= self.to(&quot;tempK&quot;)
</span><span class="marked0"><a name="line676" /> 676     @numerator = r.numerator
</span><span class="marked1"><a name="line677" /> 677     @denominator = r.denominator
</span><span class="marked0"><a name="line678" /> 678     @scalar = r.scalar
</span><span class="inferred1"><a name="line679" /> 679   end
</span><span class="inferred0"><a name="line680" /> 680   
</span><span class="inferred1"><a name="line681" /> 681   
</span><span class="marked0"><a name="line682" /> 682   private
</span><span class="inferred1"><a name="line683" /> 683   
</span><span class="marked0"><a name="line684" /> 684   def initialize_copy(other)
</span><span class="marked1"><a name="line685" /> 685     @numerator = other.numerator.clone
</span><span class="marked0"><a name="line686" /> 686     @denominator = other.denominator.clone
</span><span class="inferred1"><a name="line687" /> 687   end
</span><span class="inferred0"><a name="line688" /> 688   
</span><span class="inferred1"><a name="line689" /> 689   # calculates the unit signature id for use in comparing compatible units and simplification
</span><span class="inferred0"><a name="line690" /> 690   # the signature is based on a simple classification of units and is based on the following publication
</span><span class="inferred1"><a name="line691" /> 691   #  
</span><span class="inferred0"><a name="line692" /> 692   #  Novak, G.S., Jr. &quot;Conversion of units of measurement&quot;, IEEE Transactions on Software Engineering,
</span><span class="inferred1"><a name="line693" /> 693   #  21(8), Aug 1995, pp.651-661
</span><span class="inferred0"><a name="line694" /> 694   #  doi://10.1109/32.403789
</span><span class="inferred1"><a name="line695" /> 695   #  http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel1/32/9079/00403789.pdf?isnumber=9079&amp;prod=JNL&amp;arnumber=403789&amp;arSt=651&amp;ared=661&amp;arAuthor=Novak%2C+G.S.%2C+Jr.
</span><span class="inferred0"><a name="line696" /> 696   #
</span><span class="marked1"><a name="line697" /> 697   def unit_signature
</span><span class="marked0"><a name="line698" /> 698     vector = unit_signature_vector
</span><span class="marked1"><a name="line699" /> 699     vector.each_with_index {|item,index| vector[index] = item * 20**index}
</span><span class="marked0"><a name="line700" /> 700     @signature=vector.inject(0) {|sum,n| sum+n}
</span><span class="inferred1"><a name="line701" /> 701   end
</span><span class="inferred0"><a name="line702" /> 702   
</span><span class="marked1"><a name="line703" /> 703   def self.eliminate_terms(q, n, d)
</span><span class="marked0"><a name="line704" /> 704     num = n.clone
</span><span class="marked1"><a name="line705" /> 705     den = d.clone
</span><span class="inferred0"><a name="line706" /> 706     
</span><span class="marked1"><a name="line707" /> 707     num.delete_if {|v| v == '&lt;1&gt;'}
</span><span class="marked0"><a name="line708" /> 708     den.delete_if {|v| v == '&lt;1&gt;'}
</span><span class="marked1"><a name="line709" /> 709     combined = Hash.new(0)
</span><span class="inferred0"><a name="line710" /> 710  
</span><span class="marked1"><a name="line711" /> 711     i = 0
</span><span class="marked0"><a name="line712" /> 712     loop do 
</span><span class="marked1"><a name="line713" /> 713       break if i &gt; num.size
</span><span class="marked0"><a name="line714" /> 714       if @@PREFIX_VALUES.has_key? num[i]
</span><span class="marked1"><a name="line715" /> 715         k = [num[i],num[i+1]]
</span><span class="marked0"><a name="line716" /> 716         i += 2
</span><span class="inferred1"><a name="line717" /> 717       else
</span><span class="marked0"><a name="line718" /> 718         k = num[i]
</span><span class="marked1"><a name="line719" /> 719         i += 1
</span><span class="inferred0"><a name="line720" /> 720       end
</span><span class="marked1"><a name="line721" /> 721       combined[k] += 1 unless k.nil? || k == '&lt;1&gt;'
</span><span class="inferred0"><a name="line722" /> 722     end
</span><span class="inferred1"><a name="line723" /> 723     
</span><span class="marked0"><a name="line724" /> 724     j = 0
</span><span class="marked1"><a name="line725" /> 725     loop do
</span><span class="marked0"><a name="line726" /> 726       break if j &gt; den.size
</span><span class="marked1"><a name="line727" /> 727         if @@PREFIX_VALUES.has_key? den[j]
</span><span class="marked0"><a name="line728" /> 728           k = [den[j],den[j+1]]
</span><span class="marked1"><a name="line729" /> 729           j += 2
</span><span class="inferred0"><a name="line730" /> 730         else
</span><span class="marked1"><a name="line731" /> 731           k = den[j]
</span><span class="marked0"><a name="line732" /> 732           j += 1
</span><span class="inferred1"><a name="line733" /> 733         end
</span><span class="marked0"><a name="line734" /> 734       combined[k] -= 1 unless k.nil? || k == '&lt;1&gt;'
</span><span class="inferred1"><a name="line735" /> 735     end
</span><span class="inferred0"><a name="line736" /> 736  
</span><span class="marked1"><a name="line737" /> 737     num = []
</span><span class="marked0"><a name="line738" /> 738     den = []
</span><span class="marked1"><a name="line739" /> 739     combined.each do |key,value| 
</span><span class="inferred0"><a name="line740" /> 740       case 
</span><span class="marked1"><a name="line741" /> 741       when value &gt; 0 : value.times {num &lt;&lt; key}
</span><span class="marked0"><a name="line742" /> 742       when value &lt; 0 : value.abs.times {den &lt;&lt; key}
</span><span class="marked1"><a name="line743" /> 743       end
</span><span class="inferred0"><a name="line744" /> 744     end
</span><span class="marked1"><a name="line745" /> 745     num = [&quot;&lt;1&gt;&quot;] if num.empty?
</span><span class="marked0"><a name="line746" /> 746     den = [&quot;&lt;1&gt;&quot;] if den.empty?
</span><span class="marked1"><a name="line747" /> 747     {:scalar=&gt;q, :numerator=&gt;num.flatten.compact, :denominator=&gt;den.flatten.compact}
</span><span class="inferred0"><a name="line748" /> 748   end
</span><span class="inferred1"><a name="line749" /> 749       
</span><span class="inferred0"><a name="line750" /> 750   
</span><span class="inferred1"><a name="line751" /> 751   # parse a string into a unit object.
</span><span class="inferred0"><a name="line752" /> 752   # Typical formats like : 
</span><span class="inferred1"><a name="line753" /> 753   #  &quot;5.6 kg*m/s^2&quot;
</span><span class="inferred0"><a name="line754" /> 754   #  &quot;5.6 kg*m*s^-2&quot;
</span><span class="inferred1"><a name="line755" /> 755   #  &quot;5.6 kilogram*meter*second^-2&quot;
</span><span class="inferred0"><a name="line756" /> 756   #  &quot;2.2 kPa&quot;
</span><span class="inferred1"><a name="line757" /> 757   #  &quot;37 degC&quot;
</span><span class="inferred0"><a name="line758" /> 758   #  &quot;1&quot;  -- creates a unitless constant with value 1
</span><span class="inferred1"><a name="line759" /> 759   #  &quot;GPa&quot;  -- creates a unit with scalar 1 with units 'GPa'
</span><span class="inferred0"><a name="line760" /> 760   #  6'4&quot;  -- recognized as 6 feet + 4 inches
</span><span class="inferred1"><a name="line761" /> 761   #  8 lbs 8 oz -- recognized as 8 lbs + 8 ounces 
</span><span class="marked0"><a name="line762" /> 762   def parse(unit_string=&quot;0&quot;)
</span><span class="marked1"><a name="line763" /> 763     @numerator = ['&lt;1&gt;']
</span><span class="marked0"><a name="line764" /> 764     @denominator = ['&lt;1&gt;']
</span><span class="marked1"><a name="line765" /> 765     unit_string.gsub!(/[&lt;&gt;]/,&quot;&quot;)
</span><span class="inferred0"><a name="line766" /> 766      
</span><span class="inferred1"><a name="line767" /> 767     # Special processing for unusual unit strings
</span><span class="inferred0"><a name="line768" /> 768     # feet -- 6'5&quot;
</span><span class="marked1"><a name="line769" /> 769     feet, inches = unit_string.scan(/(\d+)\s*(?:'|ft|feet)\s*(\d+)\s*(?:&quot;|in|inches)/)[0]
</span><span class="marked0"><a name="line770" /> 770     if (feet &amp;&amp; inches)
</span><span class="marked1"><a name="line771" /> 771       result = Unit.new(&quot;#{feet} ft&quot;) + Unit.new(&quot;#{inches} inches&quot;)
</span><span class="marked0"><a name="line772" /> 772       @scalar = result.scalar
</span><span class="marked1"><a name="line773" /> 773       @numerator = result.numerator
</span><span class="marked0"><a name="line774" /> 774       @denominator = result.denominator
</span><span class="marked1"><a name="line775" /> 775       @base_scalar = result.base_scalar
</span><span class="marked0"><a name="line776" /> 776       return self
</span><span class="inferred1"><a name="line777" /> 777     end
</span><span class="inferred0"><a name="line778" /> 778 
</span><span class="inferred1"><a name="line779" /> 779     # weight -- 8 lbs 12 oz    
</span><span class="marked0"><a name="line780" /> 780     pounds, oz = unit_string.scan(/(\d+)\s*(?:#|lbs|pounds)+[\s,]*(\d+)\s*(?:oz|ounces)/)[0]
</span><span class="marked1"><a name="line781" /> 781     if (pounds &amp;&amp; oz)
</span><span class="marked0"><a name="line782" /> 782       result = Unit.new(&quot;#{pounds} lbs&quot;) + Unit.new(&quot;#{oz} oz&quot;)
</span><span class="marked1"><a name="line783" /> 783       @scalar = result.scalar
</span><span class="marked0"><a name="line784" /> 784       @numerator = result.numerator
</span><span class="marked1"><a name="line785" /> 785       @denominator = result.denominator
</span><span class="marked0"><a name="line786" /> 786       @base_scalar = result.base_scalar
</span><span class="marked1"><a name="line787" /> 787       return self
</span><span class="inferred0"><a name="line788" /> 788     end
</span><span class="marked1"><a name="line789" /> 789     @scalar, top, bottom = unit_string.scan(/([\dEe+.-]*)\s*([^\/]*)\/*(.+)*/)[0]  #parse the string into parts
</span><span class="inferred0"><a name="line790" /> 790     
</span><span class="marked1"><a name="line791" /> 791     top.scan(/([^ \*]+)(?:\^|\*\*)([\d-]+)/).each do |item|
</span><span class="marked0"><a name="line792" /> 792       n = item[1].to_i
</span><span class="marked1"><a name="line793" /> 793       x = &quot;#{item[0]} &quot;
</span><span class="inferred0"><a name="line794" /> 794       case 
</span><span class="marked1"><a name="line795" /> 795         when n&gt;=0 : top.gsub!(/#{item[0]}(\^|\*\*)#{n}/) {|s| x * n}
</span><span class="marked0"><a name="line796" /> 796         when n&lt;0 : bottom = &quot;#{bottom} #{x * -n}&quot;; top.gsub!(/#{item[0]}(\^|\*\*)#{n}/,&quot;&quot;)
</span><span class="marked1"><a name="line797" /> 797       end
</span><span class="inferred0"><a name="line798" /> 798     end 
</span><span class="inferred1"><a name="line799" /> 799 
</span><span class="marked0"><a name="line800" /> 800     bottom.gsub!(/([^* ]+)(?:\^|\*\*)(\d+)/) {|s| &quot;#{$1} &quot; * $2.to_i} if bottom
</span><span class="marked1"><a name="line801" /> 801     if @scalar.empty?
</span><span class="marked0"><a name="line802" /> 802       if top =~ /[\dEe+.-]+/
</span><span class="marked1"><a name="line803" /> 803         @scalar = top.to_f  # need this for 'number only' initialization
</span><span class="inferred0"><a name="line804" /> 804       else
</span><span class="marked1"><a name="line805" /> 805         @scalar = 1         # need this for 'unit only' intialization
</span><span class="inferred0"><a name="line806" /> 806       end
</span><span class="inferred1"><a name="line807" /> 807     else
</span><span class="marked0"><a name="line808" /> 808       @scalar = @scalar.to_f
</span><span class="inferred1"><a name="line809" /> 809     end
</span><span class="inferred0"><a name="line810" /> 810             
</span><span class="marked1"><a name="line811" /> 811     @numerator = top.scan(/(#{@@PREFIX_REGEX})*?(#{@@UNIT_REGEX})\b/).delete_if {|x| x.empty?}.compact if top
</span><span class="marked0"><a name="line812" /> 812     @denominator = bottom.scan(/(#{@@PREFIX_REGEX})*?(#{@@UNIT_REGEX})\b/).delete_if {|x| x.empty?}.compact if bottom
</span><span class="inferred1"><a name="line813" /> 813 
</span><span class="marked0"><a name="line814" /> 814     @numerator = @numerator.map do |item|
</span><span class="marked1"><a name="line815" /> 815       item.map {|x| Regexp.escape(x) if x}
</span><span class="marked0"><a name="line816" /> 816        @@PREFIX_MAP[item[0]] ? [@@PREFIX_MAP[item[0]], @@UNIT_MAP[item[1]]] : [@@UNIT_MAP[item[1]]]
</span><span class="marked1"><a name="line817" /> 817     end.flatten.compact.delete_if {|x| x.empty?}
</span><span class="inferred0"><a name="line818" /> 818 
</span><span class="marked1"><a name="line819" /> 819     @denominator = @denominator.map do |item|
</span><span class="marked0"><a name="line820" /> 820        item.map {|x| Regexp.escape(x) if x}
</span><span class="marked1"><a name="line821" /> 821        @@PREFIX_MAP[item[0]] ? [@@PREFIX_MAP[item[0]], @@UNIT_MAP[item[1]]] : [@@UNIT_MAP[item[1]]]
</span><span class="marked0"><a name="line822" /> 822     end.flatten.compact.delete_if {|x| x.empty?}
</span><span class="inferred1"><a name="line823" /> 823 
</span><span class="marked0"><a name="line824" /> 824     @numerator = ['&lt;1&gt;'] if @numerator.empty?    
</span><span class="marked1"><a name="line825" /> 825     @denominator = ['&lt;1&gt;'] if @denominator.empty?
</span><span class="marked0"><a name="line826" /> 826     self
</span><span class="inferred1"><a name="line827" /> 827   end 
</span><span class="inferred0"><a name="line828" /> 828 end
</span><span class="inferred1"><a name="line829" /> 829 
</span><span class="inferred0"><a name="line830" /> 830 # Need the 'Uncertain' gem for this to do anything helpful
</span><span class="inferred1"><a name="line831" /> 831 =begin
</span><span class="inferred0"><a name="line832" /> 832 if defined? Uncertain
</span><span class="inferred1"><a name="line833" /> 833   class Uncertain
</span><span class="inferred0"><a name="line834" /> 834     def to_unit(other=nil)
</span><span class="inferred1"><a name="line835" /> 835       other ? Unit.new(self).to(other) : Unit.new(self)
</span><span class="inferred0"><a name="line836" /> 836     end
</span><span class="inferred1"><a name="line837" /> 837     alias :unit :to_unit
</span><span class="inferred0"><a name="line838" /> 838     alias :u :to_unit
</span><span class="inferred1"><a name="line839" /> 839   end
</span><span class="inferred0"><a name="line840" /> 840 end
</span><span class="inferred1"><a name="line841" /> 841 =end
</span><span class="inferred0"><a name="line842" /> 842 
</span><span class="inferred1"><a name="line843" /> 843 # Allow date objects to do offsets by a time unit
</span><span class="inferred0"><a name="line844" /> 844 # Date.today + U&quot;1 week&quot; =&gt; gives today+1 week
</span><span class="marked1"><a name="line845" /> 845 class Date
</span><span class="marked0"><a name="line846" /> 846   alias :unit_date_add :+
</span><span class="marked1"><a name="line847" /> 847   def +(unit)
</span><span class="marked0"><a name="line848" /> 848     case unit
</span><span class="marked1"><a name="line849" /> 849     when Unit: unit_date_add(unit.to('day').scalar)
</span><span class="marked0"><a name="line850" /> 850     when Time: unit_date_add(unit.to_datetime)
</span><span class="inferred1"><a name="line851" /> 851     else
</span><span class="marked0"><a name="line852" /> 852       unit_date_add(unit)
</span><span class="inferred1"><a name="line853" /> 853     end
</span><span class="marked0"><a name="line854" /> 854   end
</span><span class="inferred1"><a name="line855" /> 855 
</span><span class="marked0"><a name="line856" /> 856   alias :unit_date_sub :-    
</span><span class="marked1"><a name="line857" /> 857   def -(unit)
</span><span class="marked0"><a name="line858" /> 858     case unit
</span><span class="marked1"><a name="line859" /> 859     when Unit: unit_date_sub(unit.to('day').scalar)
</span><span class="marked0"><a name="line860" /> 860     when Time: unit_date_sub(unit.to_datetime)
</span><span class="inferred1"><a name="line861" /> 861     else
</span><span class="marked0"><a name="line862" /> 862       unit_date_sub(unit)
</span><span class="inferred1"><a name="line863" /> 863     end
</span><span class="marked0"><a name="line864" /> 864   end
</span><span class="inferred1"><a name="line865" /> 865   
</span><span class="marked0"><a name="line866" /> 866   def to_time
</span><span class="marked1"><a name="line867" /> 867     Time.local(*ParseDate.parsedate(self.to_s))
</span><span class="marked0"><a name="line868" /> 868   end
</span><span class="inferred1"><a name="line869" /> 869   
</span><span class="marked0"><a name="line870" /> 870   alias :units_datetime_inspect :inspect
</span><span class="marked1"><a name="line871" /> 871   def inspect(raw = false)
</span><span class="marked0"><a name="line872" /> 872     return self.units_datetime_inspect if raw
</span><span class="marked1"><a name="line873" /> 873     self.to_s
</span><span class="inferred0"><a name="line874" /> 874   end
</span><span class="inferred1"><a name="line875" /> 875   
</span><span class="inferred0"><a name="line876" /> 876 end
</span><span class="inferred1"><a name="line877" /> 877 
</span><span class="marked0"><a name="line878" /> 878 class Object
</span><span class="marked1"><a name="line879" /> 879   def Unit(other)
</span><span class="marked0"><a name="line880" /> 880     other.to_unit
</span><span class="marked1"><a name="line881" /> 881   end
</span><span class="marked0"><a name="line882" /> 882   alias :U :Unit
</span><span class="marked1"><a name="line883" /> 883   alias :u :Unit
</span><span class="inferred0"><a name="line884" /> 884 end
</span><span class="inferred1"><a name="line885" /> 885 
</span><span class="inferred0"><a name="line886" /> 886 # make a unitless unit with a given scalar
</span><span class="marked1"><a name="line887" /> 887 class Numeric
</span><span class="marked0"><a name="line888" /> 888   def to_unit(other = nil)
</span><span class="marked1"><a name="line889" /> 889     other ? Unit.new(self) * Unit.new(other) : Unit.new(self)
</span><span class="marked0"><a name="line890" /> 890   end
</span><span class="marked1"><a name="line891" /> 891   alias :unit :to_unit
</span><span class="marked0"><a name="line892" /> 892   alias :u :to_unit
</span><span class="inferred1"><a name="line893" /> 893 end
</span><span class="inferred0"><a name="line894" /> 894 
</span><span class="inferred1"><a name="line895" /> 895 # make a unit from an array
</span><span class="inferred0"><a name="line896" /> 896 # [1, 'mm'].unit =&gt; 1 mm
</span><span class="marked1"><a name="line897" /> 897 class Array
</span><span class="marked0"><a name="line898" /> 898   def to_unit(other = nil)
</span><span class="marked1"><a name="line899" /> 899     other ? Unit.new(self).to(other) : Unit.new(self)
</span><span class="marked0"><a name="line900" /> 900   end
</span><span class="marked1"><a name="line901" /> 901   alias :unit :to_unit
</span><span class="marked0"><a name="line902" /> 902   alias :u :to_unit
</span><span class="inferred1"><a name="line903" /> 903 end
</span><span class="inferred0"><a name="line904" /> 904 
</span><span class="inferred1"><a name="line905" /> 905 # make a string into a unit
</span><span class="marked0"><a name="line906" /> 906 class String
</span><span class="marked1"><a name="line907" /> 907   def to_unit(other = nil)
</span><span class="marked0"><a name="line908" /> 908     other ? Unit.new(self) &gt;&gt; other : Unit.new(self)
</span><span class="marked1"><a name="line909" /> 909   end
</span><span class="marked0"><a name="line910" /> 910   alias :unit :to_unit
</span><span class="marked1"><a name="line911" /> 911   alias :u :to_unit
</span><span class="marked0"><a name="line912" /> 912   alias :unit_format :%
</span><span class="inferred1"><a name="line913" /> 913   
</span><span class="inferred0"><a name="line914" /> 914   # format unit output using formating codes '%0.2f' % '1 mm'.unit =&gt; '1.00 mm'
</span><span class="marked1"><a name="line915" /> 915   def %(*args)
</span><span class="marked0"><a name="line916" /> 916     case args[0]
</span><span class="marked1"><a name="line917" /> 917     when Unit: args[0].to_s(self)
</span><span class="marked0"><a name="line918" /> 918     when Complex: args[0].to_s
</span><span class="inferred1"><a name="line919" /> 919     else
</span><span class="marked0"><a name="line920" /> 920       unit_format(*args)
</span><span class="inferred1"><a name="line921" /> 921     end
</span><span class="marked0"><a name="line922" /> 922   end
</span><span class="inferred1"><a name="line923" /> 923     
</span><span class="marked0"><a name="line924" /> 924   def from(time_point = ::Time.now)
</span><span class="marked1"><a name="line925" /> 925     self.unit.from(time_point)
</span><span class="marked0"><a name="line926" /> 926   end
</span><span class="marked1"><a name="line927" /> 927   alias :after :from
</span><span class="marked0"><a name="line928" /> 928   alias :from_now :from
</span><span class="inferred1"><a name="line929" /> 929   
</span><span class="marked0"><a name="line930" /> 930   def ago
</span><span class="marked1"><a name="line931" /> 931     self.unit.ago
</span><span class="marked0"><a name="line932" /> 932   end
</span><span class="inferred1"><a name="line933" /> 933   
</span><span class="marked0"><a name="line934" /> 934   def before(time_point = ::Time.now)
</span><span class="marked1"><a name="line935" /> 935     self.unit.before(time_point)
</span><span class="marked0"><a name="line936" /> 936   end
</span><span class="marked1"><a name="line937" /> 937   alias :before_now :before
</span><span class="inferred0"><a name="line938" /> 938   
</span><span class="marked1"><a name="line939" /> 939   def since(time_point = ::Time.now)
</span><span class="marked0"><a name="line940" /> 940     self.unit.since(time_point)
</span><span class="marked1"><a name="line941" /> 941   end
</span><span class="inferred0"><a name="line942" /> 942   
</span><span class="marked1"><a name="line943" /> 943   def until(time_point = ::Time.now)
</span><span class="marked0"><a name="line944" /> 944     self.unit.until(time_point)
</span><span class="marked1"><a name="line945" /> 945   end
</span><span class="inferred0"><a name="line946" /> 946   
</span><span class="marked1"><a name="line947" /> 947   def to(other)
</span><span class="marked0"><a name="line948" /> 948     self.unit.to(other)
</span><span class="marked1"><a name="line949" /> 949   end
</span><span class="inferred0"><a name="line950" /> 950   
</span><span class="marked1"><a name="line951" /> 951   def to_time(options = {})
</span><span class="marked0"><a name="line952" /> 952     if defined? Chronic
</span><span class="marked1"><a name="line953" /> 953       r=Chronic.parse(self,options) || Time.local(*ParseDate.parsedate(self)) rescue DateTime.civil(*ParseDate.parsedate(self)[0..5].compact)
</span><span class="uncovered0"><a name="line954" /> 954     else
</span><span class="uncovered1"><a name="line955" /> 955       r=Time.local(*ParseDate.parsedate(self)) rescue DateTime.civil(*ParseDate.parsedate(self)[0..5].compact)
</span><span class="uncovered0"><a name="line956" /> 956     end
</span><span class="marked1"><a name="line957" /> 957     raise RuntimeError, &quot;Invalid Time String&quot; if r == DateTime.new
</span><span class="marked0"><a name="line958" /> 958     return r
</span><span class="inferred1"><a name="line959" /> 959   end
</span><span class="marked0"><a name="line960" /> 960   alias :time :to_time
</span><span class="inferred1"><a name="line961" /> 961   
</span><span class="marked0"><a name="line962" /> 962   def to_datetime(options = {})
</span><span class="marked1"><a name="line963" /> 963       r= Chronic.parse(self,options).to_datetime rescue DateTime.civil(*ParseDate.parsedate(self)[0..5].compact)
</span><span class="marked0"><a name="line964" /> 964       raise RuntimeError, &quot;Invalid Time String&quot; if r == DateTime.new      
</span><span class="marked1"><a name="line965" /> 965       return r
</span><span class="inferred0"><a name="line966" /> 966   end
</span><span class="marked1"><a name="line967" /> 967   alias :datetime :to_datetime
</span><span class="inferred0"><a name="line968" /> 968 end
</span><span class="inferred1"><a name="line969" /> 969 
</span><span class="inferred0"><a name="line970" /> 970 
</span><span class="inferred1"><a name="line971" /> 971 # Allow time objects to use 
</span><span class="marked0"><a name="line972" /> 972 class Time
</span><span class="inferred1"><a name="line973" /> 973   
</span><span class="marked0"><a name="line974" /> 974   class &lt;&lt; self
</span><span class="marked1"><a name="line975" /> 975     alias unit_time_at at
</span><span class="inferred0"><a name="line976" /> 976   end
</span><span class="inferred1"><a name="line977" /> 977   
</span><span class="marked0"><a name="line978" /> 978   def self.at(*args)
</span><span class="marked1"><a name="line979" /> 979     if Unit === args[0]
</span><span class="marked0"><a name="line980" /> 980       unit_time_at(args[0].to(&quot;s&quot;).scalar)
</span><span class="inferred1"><a name="line981" /> 981     else
</span><span class="marked0"><a name="line982" /> 982       unit_time_at(*args)
</span><span class="inferred1"><a name="line983" /> 983     end
</span><span class="marked0"><a name="line984" /> 984   end
</span><span class="inferred1"><a name="line985" /> 985   
</span><span class="marked0"><a name="line986" /> 986   def to_unit(other = &quot;s&quot;)
</span><span class="marked1"><a name="line987" /> 987     other ? Unit.new(&quot;#{self.to_f} s&quot;).to(other) : Unit.new(&quot;#{self.to_f} s&quot;)
</span><span class="marked0"><a name="line988" /> 988   end
</span><span class="marked1"><a name="line989" /> 989   alias :unit :to_unit
</span><span class="marked0"><a name="line990" /> 990   alias :u :to_unit
</span><span class="marked1"><a name="line991" /> 991   alias :unit_add :+
</span><span class="inferred0"><a name="line992" /> 992   
</span><span class="marked1"><a name="line993" /> 993   def to_datetime
</span><span class="marked0"><a name="line994" /> 994     DateTime.civil(1970,1,1)+(self.to_f+self.gmt_offset)/86400
</span><span class="marked1"><a name="line995" /> 995   end
</span><span class="inferred0"><a name="line996" /> 996   
</span><span class="marked1"><a name="line997" /> 997   def +(other)
</span><span class="marked0"><a name="line998" /> 998     case other
</span><span class="marked1"><a name="line999" /> 999     when Unit: unit_add(other.to('s').scalar)
</span><span class="marked0"><a name="line1000" />1000     when DateTime: unit_add(other.to_time)
</span><span class="inferred1"><a name="line1001" />1001     else
</span><span class="marked0"><a name="line1002" />1002       unit_add(other)
</span><span class="inferred1"><a name="line1003" />1003     end
</span><span class="marked0"><a name="line1004" />1004   end
</span><span class="inferred1"><a name="line1005" />1005   
</span><span class="marked0"><a name="line1006" />1006   def self.in(duration)
</span><span class="marked1"><a name="line1007" />1007     Time.now + duration.to_unit
</span><span class="marked0"><a name="line1008" />1008   end
</span><span class="inferred1"><a name="line1009" />1009   
</span><span class="marked0"><a name="line1010" />1010   alias :unit_sub :-
</span><span class="marked1"><a name="line1011" />1011   def -(other)
</span><span class="marked0"><a name="line1012" />1012     case other
</span><span class="marked1"><a name="line1013" />1013     when Unit: unit_sub(other.to('s').scalar)
</span><span class="marked0"><a name="line1014" />1014     when DateTime: unit_sub(other.to_time)
</span><span class="inferred1"><a name="line1015" />1015     else
</span><span class="marked0"><a name="line1016" />1016       unit_sub(other)
</span><span class="inferred1"><a name="line1017" />1017     end
</span><span class="marked0"><a name="line1018" />1018   end
</span><span class="inferred1"><a name="line1019" />1019 end
</span><span class="inferred0"><a name="line1020" />1020 
</span><span class="marked1"><a name="line1021" />1021 module Math
</span><span class="marked0"><a name="line1022" />1022   alias unit_sin sin
</span><span class="marked1"><a name="line1023" />1023    def sin(n)
</span><span class="marked0"><a name="line1024" />1024      if Unit === n
</span><span class="marked1"><a name="line1025" />1025        unit_sin(n.to('radian').scalar)
</span><span class="inferred0"><a name="line1026" />1026      else
</span><span class="marked1"><a name="line1027" />1027        unit_sin(n)
</span><span class="inferred0"><a name="line1028" />1028      end
</span><span class="marked1"><a name="line1029" />1029    end
</span><span class="inferred0"><a name="line1030" />1030 
</span><span class="marked1"><a name="line1031" />1031    alias unit_cos cos
</span><span class="marked0"><a name="line1032" />1032     def cos(n)
</span><span class="marked1"><a name="line1033" />1033       if Unit === n
</span><span class="marked0"><a name="line1034" />1034         unit_cos(n.to('radian').scalar)
</span><span class="inferred1"><a name="line1035" />1035       else
</span><span class="marked0"><a name="line1036" />1036         unit_cos(n)
</span><span class="inferred1"><a name="line1037" />1037       end
</span><span class="marked0"><a name="line1038" />1038     end
</span><span class="inferred1"><a name="line1039" />1039     
</span><span class="marked0"><a name="line1040" />1040     alias unit_sinh sinh
</span><span class="marked1"><a name="line1041" />1041      def sinh(n)
</span><span class="marked0"><a name="line1042" />1042        if Unit === n
</span><span class="marked1"><a name="line1043" />1043          unit_sinh(n.to('radian').scalar)
</span><span class="inferred0"><a name="line1044" />1044        else
</span><span class="marked1"><a name="line1045" />1045          unit_sinh(n)
</span><span class="inferred0"><a name="line1046" />1046        end
</span><span class="marked1"><a name="line1047" />1047      end
</span><span class="inferred0"><a name="line1048" />1048 
</span><span class="marked1"><a name="line1049" />1049      alias unit_cosh cosh
</span><span class="marked0"><a name="line1050" />1050       def cosh(n)
</span><span class="marked1"><a name="line1051" />1051         if Unit === n
</span><span class="marked0"><a name="line1052" />1052           unit_cosh(n.to('radian').scalar)
</span><span class="inferred1"><a name="line1053" />1053         else
</span><span class="marked0"><a name="line1054" />1054           unit_cosh(n)
</span><span class="inferred1"><a name="line1055" />1055         end
</span><span class="marked0"><a name="line1056" />1056       end
</span><span class="inferred1"><a name="line1057" />1057 
</span><span class="marked0"><a name="line1058" />1058       alias unit_tan tan
</span><span class="marked1"><a name="line1059" />1059        def tan(n)
</span><span class="marked0"><a name="line1060" />1060          if Unit === n
</span><span class="marked1"><a name="line1061" />1061            unit_tan(n.to('radian').scalar)
</span><span class="inferred0"><a name="line1062" />1062          else
</span><span class="marked1"><a name="line1063" />1063            unit_tan(n)
</span><span class="inferred0"><a name="line1064" />1064          end
</span><span class="marked1"><a name="line1065" />1065        end
</span><span class="inferred0"><a name="line1066" />1066 
</span><span class="marked1"><a name="line1067" />1067        alias unit_tanh tanh
</span><span class="marked0"><a name="line1068" />1068         def tanh(n)
</span><span class="marked1"><a name="line1069" />1069           if Unit === n
</span><span class="marked0"><a name="line1070" />1070             unit_tanh(n.to('radian').scalar)
</span><span class="inferred1"><a name="line1071" />1071           else
</span><span class="marked0"><a name="line1072" />1072             unit_tanh(n)
</span><span class="inferred1"><a name="line1073" />1073           end
</span><span class="marked0"><a name="line1074" />1074         end
</span><span class="inferred1"><a name="line1075" />1075 
</span><span class="marked0"><a name="line1076" />1076    module_function :unit_sin
</span><span class="marked1"><a name="line1077" />1077    module_function :sin
</span><span class="marked0"><a name="line1078" />1078    module_function :unit_cos
</span><span class="marked1"><a name="line1079" />1079    module_function :cos
</span><span class="marked0"><a name="line1080" />1080    module_function :unit_sinh
</span><span class="marked1"><a name="line1081" />1081    module_function :sinh
</span><span class="marked0"><a name="line1082" />1082    module_function :unit_cosh
</span><span class="marked1"><a name="line1083" />1083    module_function :cosh
</span><span class="marked0"><a name="line1084" />1084    module_function :unit_tan
</span><span class="marked1"><a name="line1085" />1085    module_function :tan
</span><span class="marked0"><a name="line1086" />1086    module_function :unit_tanh
</span><span class="marked1"><a name="line1087" />1087    module_function :tanh
</span><span class="inferred0"><a name="line1088" />1088 end
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.7.0.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
