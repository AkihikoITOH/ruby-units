    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>ruby-units.rb - Bogo-profile information</title>
        <style type='text/css'>body { background-color: rgb(179,205,255); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>Bogo-profile information</h3>
        <p>Generated on Tue Sep 26 00:38:55 EDT 2006 with <a href='http://eigenclass.org/hiki.rb?rcov'>rcov 0.7.0</a>
        </p>
        <hr />    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='ruby-units_rb.html'>ruby-units.rb</a>
          </td>
          <td class='value'>
            <tt>1104</tt>
          </td>
          <td class='value'>
            <tt>834</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt>57.5%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='58' />
                      <td class='uncovered' width='42' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt>44.5%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='44' />
                      <td class='uncovered' width='56' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="run11"><a name="line1" />   1 require 'mathn'
<a name="line2" />   2 require 'rational'
<a name="line3" />   3 require 'date'
<a name="line4" />   4 require 'parsedate'
</span><a name="line5" />   5 # = Ruby Units 0.2.3
<a name="line6" />   6 #
<a name="line7" />   7 # Copyright 2006 by Kevin C. Olbrich, Ph.D.
<a name="line8" />   8 # 
<a name="line9" />   9 # See http://rubyforge.org/ruby-units/
<a name="line10" />  10 #
<a name="line11" />  11 # http://www.sciwerks.org
<a name="line12" />  12 #
<a name="line13" />  13 # mailto://kevin.olbrich+ruby-units@gmail.com
<a name="line14" />  14 #
<a name="line15" />  15 # See README for detailed usage instructions and examples
<a name="line16" />  16 #
<a name="line17" />  17 # ==Unit Definition Format
<a name="line18" />  18 #
<a name="line19" />  19 #  '&lt;name&gt;'  =&gt; [%w{prefered_name synonyms}, conversion_to_base, :classification, %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;numerator&gt;} , %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;denominator&gt;} ],
<a name="line20" />  20 #
<a name="line21" />  21 # Prefixes (e.g., a :prefix classification) get special handling
<a name="line22" />  22 # Note: The accuracy of unit conversions depends on the precision of the conversion factor.
<a name="line23" />  23 # If you have more accurate estimates for particular conversion factors, please send them 
<a name="line24" />  24 # to me and I will incorporate them into the next release.  It is also incumbent on the end-user
<a name="line25" />  25 # to ensure that the accuracy of any conversions is sufficient for their intended application.
<a name="line26" />  26 #
<a name="line27" />  27 # While there are a large number of unit specified in the base package, 
<a name="line28" />  28 # there are also a large number of units that are not included.
<a name="line29" />  29 # This package covers nearly all SI, Imperial, and units commonly used
<a name="line30" />  30 # in the United States. If your favorite units are not listed here, send me an email
<a name="line31" />  31 #
<a name="line32" />  32 # To add / override a unit definition, add a code block like this..
<a name="line33" />  33 #
<a name="line34" />  34 #  class Unit &lt; Numeric
<a name="line35" />  35 #   UNIT_DEFINITIONS = {
<a name="line36" />  36 #    &lt;name&gt;'  =&gt; [%w{prefered_name synonyms}, conversion_to_base, :classification, %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;numerator&gt;} , %w{&lt;base&gt; &lt;units&gt; &lt;in&gt; &lt;denominator&gt;} ]
<a name="line37" />  37 #    }
<a name="line38" />  38 #  end
<a name="line39" />  39 #  Unit.setup
<span class="run16"><a name="line40" />  40 class Unit &lt; Numeric
</span><span class="run11"><a name="line41" />  41   require 'units'
</span><a name="line42" />  42   # pre-generate hashes from unit definitions for performance.  
<span class="run11"><a name="line43" />  43   @@USER_DEFINITIONS = {}
<a name="line44" />  44   @@PREFIX_VALUES = {}
<a name="line45" />  45   @@PREFIX_MAP = {}
<a name="line46" />  46   @@UNIT_MAP = {}
<a name="line47" />  47   @@UNIT_VALUES = {}
<a name="line48" />  48   @@OUTPUT_MAP = {}
<a name="line49" />  49   @@UNIT_VECTORS = {}
<a name="line50" />  50   @@BASE_UNITS = ['&lt;meter&gt;','&lt;kilogram&gt;','&lt;second&gt;','&lt;mole&gt;', '&lt;farad&gt;', '&lt;ampere&gt;','&lt;radian&gt;','&lt;kelvin&gt;','&lt;byte&gt;','&lt;dollar&gt;','&lt;candela&gt;','&lt;each&gt;','&lt;steradian&gt;','&lt;decibel&gt;']
</span><a name="line51" />  51 
<span class="run16"><a name="line52" />  52   def self.setup
</span><span class="run19"><a name="line53" />  53     (UNIT_DEFINITIONS.merge!(@@USER_DEFINITIONS)).each do |key, value|
</span><span class="run53"><a name="line54" />  54       if value[2] == :prefix then
</span><span class="run41"><a name="line55" />  55         @@PREFIX_VALUES[(key)]=value[1]
</span><span class="run50"><a name="line56" />  56         value[0].each {|x| @@PREFIX_MAP[(x)]=key}    
</span><a name="line57" />  57       else
<span class="run51"><a name="line58" />  58         @@UNIT_VALUES[(key)]={}
<a name="line59" />  59         @@UNIT_VALUES[(key)][:scalar]=value[1]
</span><span class="run54"><a name="line60" />  60         @@UNIT_VALUES[(key)][:numerator]=value[3] if value[3]
</span><span class="run53"><a name="line61" />  61         @@UNIT_VALUES[(key)][:denominator]=value[4] if value[4]
</span><span class="run59"><a name="line62" />  62         value[0].each {|x| @@UNIT_MAP[(x)]=key}
</span><span class="run51"><a name="line63" />  63         @@UNIT_VECTORS[value[2]] = [] unless @@UNIT_VECTORS[value[2]]
<a name="line64" />  64         @@UNIT_VECTORS[value[2]] = @@UNIT_VECTORS[value[2]]+[(key)]
</span><a name="line65" />  65       end
<span class="run53"><a name="line66" />  66       @@OUTPUT_MAP[(key)]=value[0][0]
</span><a name="line67" />  67     end
<span class="run43"><a name="line68" />  68     @@PREFIX_REGEX = @@PREFIX_MAP.keys.sort_by {|prefix| prefix.length}.reverse.join('|')
</span><span class="run53"><a name="line69" />  69     @@UNIT_REGEX = @@UNIT_MAP.keys.sort_by {|unit| unit.length}.reverse.join('|')
</span><a name="line70" />  70   end
<a name="line71" />  71   
<span class="run11"><a name="line72" />  72   self.setup
</span><a name="line73" />  73   
<span class="run11"><a name="line74" />  74   include Comparable
<a name="line75" />  75   attr_accessor :scalar, :numerator, :denominator, :signature, :base_scalar
</span><a name="line76" />  76 
<span class="run11"><a name="line77" />  77   def to_yaml_properties
</span><a name="line78" />  78     %w{@scalar @numerator @denominator @signature @base_scalar}
<a name="line79" />  79   end
<a name="line80" />  80   
<a name="line81" />  81   # basically a copy of the basic to_yaml.  Needed because otherwise it ends up coercing the object to a string
<a name="line82" />  82   # before YAML'izing it.
<span class="run11"><a name="line83" />  83   def to_yaml( opts = {} )
</span><a name="line84" />  84     YAML::quick_emit( object_id, opts ) do |out|
<a name="line85" />  85       out.map( taguri, to_yaml_style ) do |map|
<a name="line86" />  86         to_yaml_properties.each do |m|
<a name="line87" />  87           map.add( m[1..-1], instance_variable_get( m ) )
<a name="line88" />  88         end
<a name="line89" />  89       end
<a name="line90" />  90     end
<a name="line91" />  91   end
<a name="line92" />  92   
<a name="line93" />  93   # Create a new Unit object.  Can be initialized using a string, or a hash
<a name="line94" />  94   # Valid formats include:
<a name="line95" />  95   #  &quot;5.6 kg*m/s^2&quot;
<a name="line96" />  96   #  &quot;5.6 kg*m*s^-2&quot;
<a name="line97" />  97   #  &quot;5.6 kilogram*meter*second^-2&quot;
<a name="line98" />  98   #  &quot;2.2 kPa&quot;
<a name="line99" />  99   #  &quot;37 degC&quot;
<a name="line100" /> 100   #  &quot;1&quot;  -- creates a unitless constant with value 1
<a name="line101" /> 101   #  &quot;GPa&quot;  -- creates a unit with scalar 1 with units 'GPa'
<a name="line102" /> 102   #  6'4&quot;  -- recognized as 6 feet + 4 inches 
<a name="line103" /> 103   #  8 lbs 8 oz -- recognized as 8 lbs + 8 ounces
<a name="line104" /> 104   #
<span class="run63"><a name="line105" /> 105   def initialize(options)    
</span><span class="run68"><a name="line106" /> 106     case options
</span><span class="run65"><a name="line107" /> 107     when String: parse(options)
</span><span class="run61"><a name="line108" /> 108     when Hash:
<a name="line109" /> 109       @scalar = options[:scalar] || 1
<a name="line110" /> 110       @numerator = options[:numerator] || [&quot;&lt;1&gt;&quot;]
<a name="line111" /> 111       @denominator = options[:denominator] || []
</span><a name="line112" /> 112     when Array: 
<a name="line113" /> 113       parse(&quot;#{options[0]} #{options[1]}/#{options[2]}&quot;)
<a name="line114" /> 114     when Numeric:
<a name="line115" /> 115       @scalar = options
<a name="line116" /> 116       @numerator = @denominator = ['&lt;1&gt;']
<a name="line117" /> 117     when Time:
<a name="line118" /> 118       @scalar = options.to_f
<a name="line119" /> 119       @numerator = ['&lt;second&gt;']
<a name="line120" /> 120       @denominator = ['&lt;1&gt;']
<a name="line121" /> 121     else
<a name="line122" /> 122       raise ArgumentError, &quot;Invalid Unit Format&quot;
<a name="line123" /> 123     end
<span class="run63"><a name="line124" /> 124     self.update_base_scalar
<a name="line125" /> 125     self.replace_temperature
<a name="line126" /> 126     self.freeze
</span><a name="line127" /> 127   end
<a name="line128" /> 128   
<span class="run11"><a name="line129" /> 129   def to_unit
</span><a name="line130" /> 130     self
<a name="line131" /> 131   end
<span class="run11"><a name="line132" /> 132   alias :unit :to_unit
</span><a name="line133" /> 133   
<a name="line134" /> 134   # Returns 'true' if the Unit is represented in base units
<span class="run69"><a name="line135" /> 135   def is_base?
</span><span class="run77"><a name="line136" /> 136     return true if @signature == 400 &amp;&amp; @numerator.size == 1 &amp;&amp; @numerator[0] =~ /(celsius|kelvin|fahrenheit|rankine)/
</span><span class="run69"><a name="line137" /> 137     n = @numerator + @denominator
<a name="line138" /> 138     n.compact.each do |x|
</span><span class="run80"><a name="line139" /> 139       return false unless x == '&lt;1&gt;' || (@@BASE_UNITS.include?((x)))
</span><a name="line140" /> 140     end
<span class="run65"><a name="line141" /> 141     return true
</span><a name="line142" /> 142   end  
<a name="line143" /> 143   
<a name="line144" /> 144   #convert to base SI units
<span class="run59"><a name="line145" /> 145   def to_base
</span><span class="run67"><a name="line146" /> 146     return self if self.is_base?
</span><a name="line147" /> 147 #    return self.to('degK') if self.units =~ /temp(C|K|F|R)/ 
<span class="run59"><a name="line148" /> 148     num = []
<a name="line149" /> 149     den = []
<a name="line150" /> 150     q = @scalar
<a name="line151" /> 151     @numerator.compact.each do |unit|
</span><span class="run70"><a name="line152" /> 152         if @@PREFIX_VALUES[(unit)]
</span><span class="run61"><a name="line153" /> 153           q *= @@PREFIX_VALUES[(unit)]
</span><a name="line154" /> 154         else
<span class="run69"><a name="line155" /> 155           q *= @@UNIT_VALUES[(unit)][:scalar] if @@UNIT_VALUES[(unit)]
</span><span class="run70"><a name="line156" /> 156           num &lt;&lt; @@UNIT_VALUES[(unit)][:numerator] if @@UNIT_VALUES[(unit)] &amp;&amp; @@UNIT_VALUES[(unit)][:numerator]
</span><span class="run69"><a name="line157" /> 157           den &lt;&lt; @@UNIT_VALUES[(unit)][:denominator] if @@UNIT_VALUES[(unit)] &amp;&amp; @@UNIT_VALUES[(unit)][:denominator]
</span><a name="line158" /> 158         end
<a name="line159" /> 159     end
<span class="run59"><a name="line160" /> 160     @denominator.compact.each do |unit|
</span><span class="run67"><a name="line161" /> 161         if @@PREFIX_VALUES[(unit)]
</span><span class="run64"><a name="line162" /> 162           q /= @@PREFIX_VALUES[(unit)]
</span><a name="line163" /> 163         else
<a name="line164" /> 164           q /= @@UNIT_VALUES[(unit)][:scalar] if @@UNIT_VALUES[(unit)]
<a name="line165" /> 165           den &lt;&lt; @@UNIT_VALUES[(unit)][:numerator] if @@UNIT_VALUES[(unit)] &amp;&amp; @@UNIT_VALUES[(unit)][:numerator]
<a name="line166" /> 166           num &lt;&lt; @@UNIT_VALUES[(unit)][:denominator] if @@UNIT_VALUES[(unit)] &amp;&amp; @@UNIT_VALUES[(unit)][:denominator]
<a name="line167" /> 167         end
<a name="line168" /> 168     end
<a name="line169" /> 169     
<span class="run59"><a name="line170" /> 170     num = num.flatten.compact
<a name="line171" /> 171     den = den.flatten.compact
</span><span class="run64"><a name="line172" /> 172     num = ['&lt;1&gt;'] if num.empty?
</span><a name="line173" /> 173    
<span class="run59"><a name="line174" /> 174     Unit.new(Unit.eliminate_terms(q,num,den))
</span><a name="line175" /> 175   end
<a name="line176" /> 176   
<a name="line177" /> 177   # Generate human readable output.
<a name="line178" /> 178   # If the name of a unit is passed, the scalar will first be converted to the target unit before output.
<a name="line179" /> 179   # some named conversions are available
<a name="line180" /> 180   #
<a name="line181" /> 181   #  :ft - outputs in feet and inches (e.g., 6'4&quot;)
<a name="line182" /> 182   #  :lbs - outputs in pounds and ounces (e.g, 8 lbs, 8 oz)
<span class="run11"><a name="line183" /> 183   def to_s(target_units=nil)
</span><a name="line184" /> 184     case target_units
<a name="line185" /> 185     when :ft:
<a name="line186" /> 186       inches = self.to(&quot;in&quot;).scalar
<a name="line187" /> 187       &quot;#{(inches / 12).truncate}\'#{(inches % 12).round}\&quot;&quot;
<a name="line188" /> 188     when :lbs:
<a name="line189" /> 189       ounces = self.to(&quot;oz&quot;).scalar
<a name="line190" /> 190       &quot;#{(ounces / 16).truncate} lbs, #{(ounces % 16).round} oz&quot;
<a name="line191" /> 191     when String
<a name="line192" /> 192       begin #first try a standard format string
<a name="line193" /> 193         target_units =~ /(%[\w\d#+-.]*)*\s*(.+)*/
<a name="line194" /> 194         return self.to($2).to_s($1) if $2
<a name="line195" /> 195         &quot;#{($1 || '%g') % @scalar || 0} #{self.units}&quot;.strip
<a name="line196" /> 196       rescue #if that is malformed, try a time string
<a name="line197" /> 197         return (Time.gm(0) + self).strftime(target_units)
<a name="line198" /> 198       end
<a name="line199" /> 199     else
<a name="line200" /> 200       &quot;#{'%g' % @scalar} #{self.units}&quot;.strip
<a name="line201" /> 201     end    
<a name="line202" /> 202   end
<a name="line203" /> 203   
<span class="run11"><a name="line204" /> 204   def inspect(option=nil)
</span><a name="line205" /> 205     return super() if option == :dump
<a name="line206" /> 206     self.to_s
<a name="line207" /> 207   end
<a name="line208" /> 208   
<a name="line209" /> 209   # returns true if no associated units
<span class="run11"><a name="line210" /> 210   def unitless?
</span><a name="line211" /> 211     (@numerator == ['&lt;1&gt;'] &amp;&amp; @denominator == ['&lt;1&gt;'])
<a name="line212" /> 212   end
<a name="line213" /> 213   
<a name="line214" /> 214   # Compare two Unit objects. Throws an exception if they are not of compatible types.
<a name="line215" /> 215   # Comparisons are done based on the value of the unit in base SI units.
<span class="run11"><a name="line216" /> 216   def &lt;=&gt;(other)
</span><a name="line217" /> 217     case other
<a name="line218" /> 218     when Unit:
<a name="line219" /> 219       raise ArgumentError, &quot;Incompatible Units&quot; unless self =~ other
<a name="line220" /> 220       self.base_scalar &lt;=&gt; other.base_scalar
<a name="line221" /> 221     else
<a name="line222" /> 222       x,y = coerce(other)
<a name="line223" /> 223       x &lt;=&gt; y
<a name="line224" /> 224     end
<a name="line225" /> 225   end
<a name="line226" /> 226   
<a name="line227" /> 227   # check to see if units are compatible, but not the scalar part
<a name="line228" /> 228   # this check is done by comparing signatures for performance reasons
<a name="line229" /> 229   # if passed a string, it will create a unit object with the string and then do the comparison
<a name="line230" /> 230   # this permits a syntax like:  
<a name="line231" /> 231   #  unit =~ &quot;mm&quot;
<a name="line232" /> 232   # if you want to do a regexp on the unit string do this ...
<a name="line233" /> 233   #  unit.units =~ /regexp/
<span class="run52"><a name="line234" /> 234   def =~(other)
<a name="line235" /> 235     case other
</span><span class="run57"><a name="line236" /> 236     when Unit : self.signature == other.signature
</span><a name="line237" /> 237     else
<a name="line238" /> 238       x,y = coerce(other)
<a name="line239" /> 239       x =~ y
<a name="line240" /> 240     end 
<span class="run52"><a name="line241" /> 241   end
</span><a name="line242" /> 242   
<span class="run11"><a name="line243" /> 243   alias :compatible? :=~
<a name="line244" /> 244   alias :compatible_with? :=~
</span><a name="line245" /> 245   
<a name="line246" /> 246   # Compare two units.  Returns true if quantities and units match
<a name="line247" /> 247   #
<a name="line248" /> 248   # Unit(&quot;100 cm&quot;) === Unit(&quot;100 cm&quot;)   # =&gt; true
<a name="line249" /> 249   # Unit(&quot;100 cm&quot;) === Unit(&quot;1 m&quot;)      # =&gt; false
<span class="run11"><a name="line250" /> 250   def ===(other)
</span><a name="line251" /> 251     case other
<a name="line252" /> 252     when Unit: (self.scalar == other.scalar) &amp;&amp; (self.units == other.units)
<a name="line253" /> 253     else
<a name="line254" /> 254       x,y = coerce(other)
<a name="line255" /> 255       x === y
<a name="line256" /> 256     end
<a name="line257" /> 257   end
<a name="line258" /> 258   
<span class="run11"><a name="line259" /> 259   alias :same? :===
<a name="line260" /> 260   alias :same_as? :===
</span><a name="line261" /> 261   
<a name="line262" /> 262   # Add two units together.  Result is same units as receiver and scalar and base_scalar are updated appropriately
<a name="line263" /> 263   # throws an exception if the units are not compatible.
<span class="run45"><a name="line264" /> 264   def +(other)   
</span><span class="run50"><a name="line265" /> 265     if Unit === other 
<a name="line266" /> 266       if self =~ other then
</span><span class="run44"><a name="line267" /> 267         a = self.to_base
<a name="line268" /> 268         b = other.to_base
</span><span class="run50"><a name="line269" /> 269         Unit.new(:scalar=&gt;(a.scalar + b.scalar), :numerator=&gt;a.numerator, :denominator=&gt;b.denominator).to(self)
</span><a name="line270" /> 270       else
<a name="line271" /> 271          raise ArgumentError,  &quot;Incompatible Units&quot;
<a name="line272" /> 272       end
<a name="line273" /> 273     elsif Time === other
<a name="line274" /> 274       other + self
<a name="line275" /> 275     else
<a name="line276" /> 276         x,y = coerce(other)
<a name="line277" /> 277         y + x
<a name="line278" /> 278     end
<span class="run44"><a name="line279" /> 279   end
</span><a name="line280" /> 280   
<a name="line281" /> 281   # Subtract two units. Result is same units as receiver and scalar and base_scalar are updated appropriately
<a name="line282" /> 282   # throws an exception if the units are not compatible.
<span class="run11"><a name="line283" /> 283   def -(other)
</span><a name="line284" /> 284     if Unit === other 
<a name="line285" /> 285       if self =~ other then
<a name="line286" /> 286         a = self.to_base
<a name="line287" /> 287         b = other.to_base
<a name="line288" /> 288         Unit.new(:scalar=&gt;(a.scalar - b.scalar), :numerator=&gt;a.numerator, :denominator=&gt;b.denominator).to(self)
<a name="line289" /> 289       else
<a name="line290" /> 290          raise ArgumentError,  &quot;Incompatible Units&quot;
<a name="line291" /> 291       end
<a name="line292" /> 292     elsif Time === other
<a name="line293" /> 293       other - self
<a name="line294" /> 294     else
<a name="line295" /> 295         x,y = coerce(other)
<a name="line296" /> 296         x - y
<a name="line297" /> 297     end
<a name="line298" /> 298   end
<a name="line299" /> 299   
<a name="line300" /> 300   # Multiply two units.
<span class="run11"><a name="line301" /> 301   def *(other)
</span><a name="line302" /> 302     if Unit === other
<a name="line303" /> 303       Unit.new(Unit.eliminate_terms(@scalar*other.scalar, @numerator + other.numerator ,@denominator + other.denominator))      
<a name="line304" /> 304     else
<a name="line305" /> 305       x,y = coerce(other)
<a name="line306" /> 306       x * y
<a name="line307" /> 307     end
<a name="line308" /> 308   end
<a name="line309" /> 309   
<a name="line310" /> 310   # Divide two units.
<a name="line311" /> 311   # Throws an exception if divisor is 0
<span class="run11"><a name="line312" /> 312   def /(other)
</span><a name="line313" /> 313     if Unit === other
<a name="line314" /> 314       raise ZeroDivisionError if other.zero?
<a name="line315" /> 315       Unit.new(Unit.eliminate_terms(@scalar/other.scalar, @numerator + other.denominator ,@denominator + other.numerator))      
<a name="line316" /> 316     else
<a name="line317" /> 317       x,y = coerce(other)
<a name="line318" /> 318       y / x
<a name="line319" /> 319     end
<a name="line320" /> 320   end
<a name="line321" /> 321     
<a name="line322" /> 322   # Exponentiate.  Only takes integer powers. 
<a name="line323" /> 323   # Note that anything raised to the power of 0 results in a Unit object with a scalar of 1, and no units.
<a name="line324" /> 324   # Throws an exception if exponent is not an integer.
<a name="line325" /> 325   # Ideally this routine should accept a float for the exponent
<a name="line326" /> 326   # It should then convert the float to a rational and raise the unit by the numerator and root it by the denominator
<a name="line327" /> 327   # but, sadly, floats can't be converted to rationals.
<a name="line328" /> 328   #
<a name="line329" /> 329   # For now, if a rational is passed in, it will be used, otherwise we are stuck with integers and certain floats &lt; 1
<span class="run11"><a name="line330" /> 330   def **(other)
</span><a name="line331" /> 331     if Numeric === other
<a name="line332" /> 332       return Unit(&quot;1&quot;) if other.zero?
<a name="line333" /> 333       return self if other == 1
<a name="line334" /> 334       return self.inverse if other == -1
<a name="line335" /> 335     end
<a name="line336" /> 336     case other
<a name="line337" /> 337     when Rational:
<a name="line338" /> 338       self.power(other.numerator).root(other.denominator)
<a name="line339" /> 339     when Integer:
<a name="line340" /> 340       self.power(other)
<a name="line341" /> 341     when Float:
<a name="line342" /> 342       return self**(other.to_i) if other == other.to_i
<a name="line343" /> 343       valid = (1..9).map {|x| 1/x}
<a name="line344" /> 344       raise ArgumentError, &quot;Not a n-th root (1..9), use 1/n&quot; unless valid.include? other.abs
<a name="line345" /> 345       self.root((1/other).to_int)
<a name="line346" /> 346     else
<a name="line347" /> 347       raise ArgumentError, &quot;Invalid Exponent&quot;
<a name="line348" /> 348     end
<a name="line349" /> 349   end
<a name="line350" /> 350   
<a name="line351" /> 351 
<a name="line352" /> 352   # returns the unit raised to the n-th power.  Integers only
<span class="run11"><a name="line353" /> 353   def power(n)
</span><a name="line354" /> 354     raise ArgumentError, &quot;Can only use Integer exponenents&quot; unless Integer === n
<a name="line355" /> 355     return self if n == 1
<a name="line356" /> 356     return Unit(&quot;1&quot;) if n == 0
<a name="line357" /> 357     return self.inverse if n == -1
<a name="line358" /> 358     if n &gt; 0 then 
<a name="line359" /> 359       (1..n.to_i).inject(Unit.new(&quot;1&quot;)) {|product, x| product * self}
<a name="line360" /> 360     else
<a name="line361" /> 361       (1..-n.to_i).inject(Unit.new(&quot;1&quot;)) {|product, x| product / self}
<a name="line362" /> 362     end
<a name="line363" /> 363   end
<a name="line364" /> 364   
<a name="line365" /> 365   # Calculates the n-th root of a unit, where n = (1..9)
<a name="line366" /> 366   # if n &lt; 0, returns 1/unit^(1/n)
<span class="run11"><a name="line367" /> 367   def root(n)
</span><a name="line368" /> 368     raise ArgumentError, &quot;Exponent must an Integer&quot; unless Integer === n
<a name="line369" /> 369     raise ArgumentError, &quot;0th root undefined&quot; if n == 0
<a name="line370" /> 370     return self if n == 1
<a name="line371" /> 371     return self.root(n.abs).inverse if n &lt; 0
<a name="line372" /> 372     
<a name="line373" /> 373     vec = self.unit_signature_vector
<a name="line374" /> 374     vec=vec.map {|x| x % n}      
<a name="line375" /> 375     raise ArgumentError, &quot;Illegal root&quot; unless vec.max == 0
<a name="line376" /> 376     num = @numerator.clone
<a name="line377" /> 377     den = @denominator.clone
<a name="line378" /> 378       
<a name="line379" /> 379     @numerator.uniq.each do |item|
<a name="line380" /> 380       x = num.find_all {|i| i==item}.size
<a name="line381" /> 381       r = ((x/n)*(n-1)).to_int
<a name="line382" /> 382       r.times {|x| num.delete_at(num.index(item))}
<a name="line383" /> 383     end
<a name="line384" /> 384     
<a name="line385" /> 385     @denominator.uniq.each do |item|
<a name="line386" /> 386       x = den.find_all {|i| i==item}.size
<a name="line387" /> 387       r = ((x/n)*(n-1)).to_int
<a name="line388" /> 388       r.times {|x| den.delete_at(den.index(item))}
<a name="line389" /> 389     end
<a name="line390" /> 390     q = @scalar**(1/n)    
<a name="line391" /> 391     Unit.new(:scalar=&gt;q,:numerator=&gt;num,:denominator=&gt;den)    
<a name="line392" /> 392   end
<a name="line393" /> 393   
<a name="line394" /> 394   # returns inverse of Unit (1/unit)
<span class="run11"><a name="line395" /> 395   def inverse
</span><a name="line396" /> 396     Unit(&quot;1&quot;) / self
<a name="line397" /> 397   end
<a name="line398" /> 398   
<a name="line399" /> 399   # convert to a specified unit string or to the same units as another Unit
<a name="line400" /> 400   # 
<a name="line401" /> 401   #  unit &gt;&gt; &quot;kg&quot;  will covert to kilograms
<a name="line402" /> 402   #  unit1 &gt;&gt; unit2 converts to same units as unit2 object
<a name="line403" /> 403   # 
<a name="line404" /> 404   # To convert a Unit object to match another Unit object, use:
<a name="line405" /> 405   #  unit1 &gt;&gt;= unit2
<a name="line406" /> 406   # Throws an exception if the requested target units are incompatible with current Unit.
<a name="line407" /> 407   #
<a name="line408" /> 408   # Special handling for temperature conversions is supported.  If the Unit object is converted
<a name="line409" /> 409   # from one temperature unit to another, the proper temperature offsets will be used.
<a name="line410" /> 410   # Supports Kelvin, Celcius, fahrenheit, and Rankine scales.
<a name="line411" /> 411   #
<a name="line412" /> 412   # Note that if temperature is part of a compound unit, the temperature will be treated as a differential
<a name="line413" /> 413   # and the units will be scaled appropriately.
<span class="run50"><a name="line414" /> 414   def to(other)
</span><span class="run57"><a name="line415" /> 415     return self if other.nil? 
</span><span class="run55"><a name="line416" /> 416     return self if TrueClass === other
<a name="line417" /> 417     return self if FalseClass === other
</span><span class="run60"><a name="line418" /> 418     if (Unit === other &amp;&amp; other.units =~ /temp(K|C|R|F)/) || (String === other &amp;&amp; other =~ /temp(K|C|R|F)/) 
</span><a name="line419" /> 419       raise ArgumentError, &quot;Receiver is not a temperature unit&quot; unless self.signature==400 
<a name="line420" /> 420       return self.to_base.to(other) unless self.is_base?
<a name="line421" /> 421       start_unit = self.units
<a name="line422" /> 422       target_unit = other.units rescue other
<a name="line423" /> 423       q=case start_unit
<a name="line424" /> 424          when 'degC':
<a name="line425" /> 425           case target_unit
<a name="line426" /> 426             when 'tempC'  : @scalar
<a name="line427" /> 427             when 'tempK'  : @scalar + 273.15
<a name="line428" /> 428             when 'tempF'  : @scalar * (9.0/5.0) + 32.0
<a name="line429" /> 429             when 'tempR'  : @scalar * (9.0/5.0) + 491.67
<a name="line430" /> 430           end
<a name="line431" /> 431         when 'degK':
<a name="line432" /> 432           case target_unit
<a name="line433" /> 433             when 'tempC'  : @scalar - 273.15
<a name="line434" /> 434             when 'tempK'  : @scalar 
<a name="line435" /> 435             when 'tempF'  : @scalar * (9.0/5.0) - 459.67
<a name="line436" /> 436             when 'tempR'  : @scalar * (9.0/5.0) 
<a name="line437" /> 437           end
<a name="line438" /> 438         when 'degF':
<a name="line439" /> 439           case target_unit
<a name="line440" /> 440             when 'tempC'  : (@scalar-32)*(5.0/9.0)
<a name="line441" /> 441             when 'tempK'  : (@scalar+459.67)*(5.0/9.0)
<a name="line442" /> 442             when 'tempF'  : @scalar 
<a name="line443" /> 443             when 'tempR'  : @scalar  + 459.67
<a name="line444" /> 444           end
<a name="line445" /> 445         when 'degR':
<a name="line446" /> 446           case target_unit
<a name="line447" /> 447             when 'tempC'  : @scalar*(5.0/9.0) -273.15
<a name="line448" /> 448             when 'tempK'  : @scalar*(5.0/9.0)
<a name="line449" /> 449             when 'tempF'  : @scalar - 459.67
<a name="line450" /> 450             when 'tempR'  : @scalar
<a name="line451" /> 451           end
<a name="line452" /> 452         else
<a name="line453" /> 453           raise ArgumentError, &quot;Unknown temperature conversion requested #{self.numerator}&quot;
<a name="line454" /> 454       end
<a name="line455" /> 455       target_unit =~ /temp(C|K|F|R)/
<a name="line456" /> 456       Unit.new(&quot;#{q} deg#{$1}&quot;)
<a name="line457" /> 457     else
<span class="run50"><a name="line458" /> 458        case other
<a name="line459" /> 459           when Unit: 
<a name="line460" /> 460             return self if other.units == self.units
</span><span class="run44"><a name="line461" /> 461             target = other
</span><span class="run50"><a name="line462" /> 462           when String: target = Unit.new(other)
</span><a name="line463" /> 463           else
<a name="line464" /> 464             raise ArgumentError, &quot;Unknown target units&quot;
<a name="line465" /> 465         end
<span class="run55"><a name="line466" /> 466       raise ArgumentError,  &quot;Incompatible Units&quot; unless self =~ target
</span><span class="run66"><a name="line467" /> 467       one = @numerator.map {|x| @@PREFIX_VALUES[(x)] ? @@PREFIX_VALUES[(x)] : x}.map {|i| i.kind_of?(Numeric) ? i : @@UNIT_VALUES[(i)][:scalar] }.compact
</span><span class="run64"><a name="line468" /> 468       two = @denominator.map {|x| @@PREFIX_VALUES[(x)] ? @@PREFIX_VALUES[(x)] : x}.map {|i| i.kind_of?(Numeric) ? i : @@UNIT_VALUES[(i)][:scalar] }.compact
</span><span class="run59"><a name="line469" /> 469       v = one.inject(1) {|product,n| product*n} / two.inject(1) {|product,n| product*n}
</span><span class="run66"><a name="line470" /> 470       one = target.numerator.map {|x| @@PREFIX_VALUES[(x)] ? @@PREFIX_VALUES[(x)] : x}.map {|x| x.kind_of?(Numeric) ? x : @@UNIT_VALUES[(x)][:scalar] }.compact
</span><span class="run64"><a name="line471" /> 471       two = target.denominator.map {|x| @@PREFIX_VALUES[(x)] ? @@PREFIX_VALUES[(x)] : x}.map {|x| x.kind_of?(Numeric) ? x : @@UNIT_VALUES[(x)][:scalar] }.compact
</span><span class="run59"><a name="line472" /> 472       y = one.inject(1) {|product,n| product*n} / two.inject(1) {|product,n| product*n}
</span><span class="run50"><a name="line473" /> 473       q = @scalar * v/y
<a name="line474" /> 474       Unit.new(:scalar=&gt;q, :numerator=&gt;target.numerator, :denominator=&gt;target.denominator)
</span><a name="line475" /> 475     end
<a name="line476" /> 476   end  
<span class="run11"><a name="line477" /> 477   alias :&gt;&gt; :to
<a name="line478" /> 478   alias :convert_to :to
</span><a name="line479" /> 479     
<a name="line480" /> 480   # Eliminates terms in the passed numerator and denominator.  Expands out prefixes and applies them to the 
<a name="line481" /> 481   # scalar.  Returns a hash that can be used to initialize a new Unit object. 
<a name="line482" /> 482   # converts the unit back to a float if it is unitless
<span class="run11"><a name="line483" /> 483   def to_f
</span><a name="line484" /> 484     return @scalar.to_f if self.unitless?
<a name="line485" /> 485     raise RuntimeError, &quot;Can't convert to float unless unitless.  Use Unit#scalar&quot;
<a name="line486" /> 486   end
<a name="line487" /> 487   
<a name="line488" /> 488   # returns the 'unit' part of the Unit object without the scalar
<span class="run52"><a name="line489" /> 489   def units
</span><span class="run60"><a name="line490" /> 490     return &quot;&quot; if @numerator == [&quot;&lt;1&gt;&quot;] &amp;&amp; @denominator == [&quot;&lt;1&gt;&quot;]
</span><span class="run52"><a name="line491" /> 491     output_n = []
<a name="line492" /> 492     output_d =[] 
<a name="line493" /> 493     num = @numerator.clone.compact
<a name="line494" /> 494     den = @denominator.clone.compact
</span><span class="run57"><a name="line495" /> 495     if @numerator == [&quot;&lt;1&gt;&quot;]
</span><a name="line496" /> 496       output_n &lt;&lt; &quot;1&quot;
<a name="line497" /> 497     else
<span class="run52"><a name="line498" /> 498       num.each_with_index do |token,index|
</span><span class="run63"><a name="line499" /> 499         if token &amp;&amp; @@PREFIX_VALUES[(token)] then
</span><span class="run57"><a name="line500" /> 500           output_n &lt;&lt; &quot;#{@@OUTPUT_MAP[(token)]}#{@@OUTPUT_MAP[(num[index+1])]}&quot;
</span><span class="run50"><a name="line501" /> 501           num[index+1]=nil
</span><a name="line502" /> 502         else
<span class="run59"><a name="line503" /> 503           output_n &lt;&lt; &quot;#{@@OUTPUT_MAP[(token)]}&quot; if token
</span><a name="line504" /> 504         end
<a name="line505" /> 505       end
<a name="line506" /> 506     end
<span class="run57"><a name="line507" /> 507     if @denominator == ['&lt;1&gt;']
</span><span class="run52"><a name="line508" /> 508       output_d = ['1']
</span><a name="line509" /> 509     else
<a name="line510" /> 510       den.each_with_index do |token,index|
<a name="line511" /> 511           if token &amp;&amp; @@PREFIX_VALUES[(token)] then
<a name="line512" /> 512             output_d &lt;&lt; &quot;#{@@OUTPUT_MAP[(token)]}#{@@OUTPUT_MAP[(den[index+1])]}&quot;
<a name="line513" /> 513             den[index+1]=nil
<a name="line514" /> 514           else
<a name="line515" /> 515             output_d &lt;&lt; &quot;#{@@OUTPUT_MAP[(token)]}&quot; if token
<a name="line516" /> 516           end
<a name="line517" /> 517         end
<a name="line518" /> 518     end
<span class="run67"><a name="line519" /> 519     on = output_n.reject {|x| x.empty?}.map {|x| [x, output_n.find_all {|z| z==x}.size]}.uniq.map {|x| (&quot;#{x[0]}&quot;.strip+ (x[1] &gt; 1 ? &quot;^#{x[1]}&quot; : ''))}
<a name="line520" /> 520     od = output_d.reject {|x| x.empty?}.map {|x| [x, output_d.find_all {|z| z==x}.size]}.uniq.map {|x| (&quot;#{x[0]}&quot;.strip+ (x[1] &gt; 1 ? &quot;^#{x[1]}&quot; : ''))}
</span><span class="run57"><a name="line521" /> 521     &quot;#{on.join('*')}#{od == ['1'] ? '': '/'+od.join('*')}&quot;.strip    
</span><a name="line522" /> 522   end
<a name="line523" /> 523   
<a name="line524" /> 524   # negates the scalar of the Unit
<span class="run11"><a name="line525" /> 525   def -@
</span><a name="line526" /> 526     Unit.new([-@scalar,@numerator,@denominator])    
<a name="line527" /> 527   end
<a name="line528" /> 528   
<a name="line529" /> 529   # returns abs of scalar, without the units
<span class="run11"><a name="line530" /> 530   def abs
</span><a name="line531" /> 531     return @scalar.abs
<a name="line532" /> 532   end
<a name="line533" /> 533   
<span class="run11"><a name="line534" /> 534   def ceil
</span><a name="line535" /> 535     Unit.new([@scalar.ceil, @numerator, @denominator])    
<a name="line536" /> 536   end
<a name="line537" /> 537   
<span class="run11"><a name="line538" /> 538   def floor
</span><a name="line539" /> 539     Unit.new([@scalar.floor, @numerator, @denominator])    
<a name="line540" /> 540   end
<a name="line541" /> 541 
<a name="line542" /> 542   # changes internal scalar to an integer, but retains the units
<a name="line543" /> 543   # if unitless, returns an int
<span class="run11"><a name="line544" /> 544   def to_int
</span><a name="line545" /> 545     return @scalar.to_int if unitless?
<a name="line546" /> 546     Unit.new([@scalar.to_int, @numerator, @denominator])    
<a name="line547" /> 547   end
<a name="line548" /> 548   
<a name="line549" /> 549   # Tries to make a Time object from current unit
<span class="run11"><a name="line550" /> 550   def to_time
</span><a name="line551" /> 551     Time.at(self)
<a name="line552" /> 552   end
<span class="run11"><a name="line553" /> 553   alias :time :to_time
<a name="line554" /> 554   alias :to_i :to_int
<a name="line555" /> 555   alias :truncate :to_int
</span><a name="line556" /> 556   
<span class="run11"><a name="line557" /> 557   def round
</span><a name="line558" /> 558     Unit.new([@scalar.round, @numerator, @denominator])    
<a name="line559" /> 559   end
<a name="line560" /> 560    
<a name="line561" /> 561   # true if scalar is zero
<span class="run11"><a name="line562" /> 562   def zero?
</span><a name="line563" /> 563     return @scalar.zero?
<a name="line564" /> 564   end
<a name="line565" /> 565   
<a name="line566" /> 566   # '5 min'.unit.ago 
<span class="run11"><a name="line567" /> 567   def ago
</span><a name="line568" /> 568     self.before
<a name="line569" /> 569   end
<a name="line570" /> 570   
<a name="line571" /> 571   # '5 min'.before(time)
<span class="run11"><a name="line572" /> 572   def before(time_point = ::Time.now)
</span><a name="line573" /> 573     raise ArgumentError, &quot;Must specify a Time&quot; unless time_point
<a name="line574" /> 574     if String === time_point
<a name="line575" /> 575       time_point.time - self rescue time_point.datetime - self
<a name="line576" /> 576     else
<a name="line577" /> 577       time_point - self rescue time_point.to_datetime - self
<a name="line578" /> 578     end
<a name="line579" /> 579   end
<span class="run11"><a name="line580" /> 580   alias :before_now :before
</span><a name="line581" /> 581   
<a name="line582" /> 582   # 'min'.since(time)
<span class="run11"><a name="line583" /> 583   def since(time_point = ::Time.now)
</span><a name="line584" /> 584     case time_point
<a name="line585" /> 585     when Time:      (Time.now - time_point).unit('s').to(self)
<a name="line586" /> 586     when DateTime, Date:  (DateTime.now - time_point).unit('d').to(self)
<a name="line587" /> 587     when String:    
<a name="line588" /> 588       (DateTime.now - time_point.time(:context=&gt;:past)).unit('d').to(self)
<a name="line589" /> 589     else
<a name="line590" /> 590       raise ArgumentError, &quot;Must specify a Time, DateTime, or String&quot; 
<a name="line591" /> 591     end
<a name="line592" /> 592   end
<a name="line593" /> 593   
<a name="line594" /> 594   # 'min'.until(time)
<span class="run11"><a name="line595" /> 595   def until(time_point = ::Time.now)
</span><a name="line596" /> 596     case time_point
<a name="line597" /> 597     when Time:      (time_point - Time.now).unit('s').to(self)
<a name="line598" /> 598     when DateTime, Date:  (time_point - DateTime.now).unit('d').to(self)
<a name="line599" /> 599     when String:
<a name="line600" /> 600       r = (time_point.time(:context=&gt;:future) - DateTime.now)
<a name="line601" /> 601       Time === time_point.time ? r.unit('s').to(self) : r.unit('d').to(self)
<a name="line602" /> 602     else
<a name="line603" /> 603       raise ArgumentError, &quot;Must specify a Time, DateTime, or String&quot; 
<a name="line604" /> 604     end
<a name="line605" /> 605   end
<a name="line606" /> 606   
<a name="line607" /> 607   # '5 min'.from(time)
<span class="run11"><a name="line608" /> 608   def from(time_point = ::Time.now)
</span><a name="line609" /> 609     raise ArgumentError, &quot;Must specify a Time&quot; unless time_point
<a name="line610" /> 610     if String === time_point
<a name="line611" /> 611       time_point.time + self rescue time_point.datetime + self
<a name="line612" /> 612     else
<a name="line613" /> 613       time_point + self rescue time_point.to_datetime + self
<a name="line614" /> 614     end
<a name="line615" /> 615   end
<span class="run11"><a name="line616" /> 616   alias :after :from
<a name="line617" /> 617   alias :from_now :from
</span><a name="line618" /> 618       
<span class="run11"><a name="line619" /> 619   def succ
</span><a name="line620" /> 620     raise ArgumentError, &quot;Non Integer Scalar&quot; unless @scalar == @scalar.to_i
<a name="line621" /> 621     q = @scalar.to_i.succ
<a name="line622" /> 622     Unit.new([q, @numerator, @denominator])
<a name="line623" /> 623   end
<a name="line624" /> 624       
<a name="line625" /> 625   # Protected and Private Functions that should only be called from this class
<span class="run11"><a name="line626" /> 626   protected
</span><a name="line627" /> 627   
<a name="line628" /> 628   
<span class="run63"><a name="line629" /> 629   def update_base_scalar
</span><span class="run68"><a name="line630" /> 630     if self.is_base?
</span><span class="run60"><a name="line631" /> 631       @base_scalar = @scalar
<a name="line632" /> 632       @signature = unit_signature
</span><a name="line633" /> 633     else
<span class="run56"><a name="line634" /> 634       base = self.to_base
<a name="line635" /> 635       @base_scalar = base.scalar
<a name="line636" /> 636       @signature = base.signature
</span><a name="line637" /> 637     end
<span class="run63"><a name="line638" /> 638   end
</span><a name="line639" /> 639   
<a name="line640" /> 640   
<span class="run11"><a name="line641" /> 641   def coerce(other)
</span><a name="line642" /> 642     case other
<a name="line643" /> 643     when Unit : [other, self]
<a name="line644" /> 644     else 
<a name="line645" /> 645       [Unit.new(other), self]
<a name="line646" /> 646     end
<a name="line647" /> 647   end
<a name="line648" /> 648   
<a name="line649" /> 649   
<a name="line650" /> 650   # calculates the unit signature vector used by unit_signature
<span class="run60"><a name="line651" /> 651   def unit_signature_vector
</span><span class="run67"><a name="line652" /> 652       return self.to_base.unit_signature_vector unless self.is_base?
</span><span class="run60"><a name="line653" /> 653       result = self
<a name="line654" /> 654       y = [:length, :time, :temperature, :mass, :current, :substance, :luminosity, :currency, :memory, :angle]
<a name="line655" /> 655       vector = Array.new(y.size,0)
<a name="line656" /> 656       y.each_with_index do |units,index|
</span><span class="run81"><a name="line657" /> 657         vector[index] = result.numerator.compact.find_all {|x| @@UNIT_VECTORS[units].include? x}.size
<a name="line658" /> 658         vector[index] -= result.denominator.compact.find_all {|x| @@UNIT_VECTORS[units].include? x}.size  
</span><a name="line659" /> 659       end
<span class="run60"><a name="line660" /> 660       vector
</span><a name="line661" /> 661   end
<a name="line662" /> 662   
<span class="run63"><a name="line663" /> 663   def replace_temperature
</span><span class="run71"><a name="line664" /> 664     return self unless self.signature == 400 &amp;&amp; self.units =~ /temp(R|K|F|C)/
</span><a name="line665" /> 665     un = $1
<a name="line666" /> 666     target = self.units
<a name="line667" /> 667     @numerator = case un
<a name="line668" /> 668       when 'R' : ['&lt;rankine&gt;']
<a name="line669" /> 669       when 'C' : ['&lt;celsius&gt;']
<a name="line670" /> 670       when 'F' : ['&lt;fahrenheit&gt;']
<a name="line671" /> 671       when 'K' : ['&lt;kelvin&gt;']
<a name="line672" /> 672     end
<a name="line673" /> 673     r= self.to(&quot;tempK&quot;)
<a name="line674" /> 674     @numerator = r.numerator
<a name="line675" /> 675     @denominator = r.denominator
<a name="line676" /> 676     @scalar = r.scalar
<a name="line677" /> 677   end
<a name="line678" /> 678   
<a name="line679" /> 679   
<span class="run11"><a name="line680" /> 680   private
</span><a name="line681" /> 681   
<span class="run11"><a name="line682" /> 682   def initialize_copy(other)
</span><a name="line683" /> 683     @numerator = other.numerator.clone
<a name="line684" /> 684     @denominator = other.denominator.clone
<a name="line685" /> 685   end
<a name="line686" /> 686   
<a name="line687" /> 687   # calculates the unit signature id for use in comparing compatible units and simplification
<a name="line688" /> 688   # the signature is based on a simple classification of units and is based on the following publication
<a name="line689" /> 689   #  
<a name="line690" /> 690   #  Novak, G.S., Jr. &quot;Conversion of units of measurement&quot;, IEEE Transactions on Software Engineering,
<a name="line691" /> 691   #  21(8), Aug 1995, pp.651-661
<a name="line692" /> 692   #  doi://10.1109/32.403789
<a name="line693" /> 693   #  http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel1/32/9079/00403789.pdf?isnumber=9079&amp;prod=JNL&amp;arnumber=403789&amp;arSt=651&amp;ared=661&amp;arAuthor=Novak%2C+G.S.%2C+Jr.
<a name="line694" /> 694   #
<span class="run60"><a name="line695" /> 695   def unit_signature
</span><span class="run65"><a name="line696" /> 696     vector = unit_signature_vector
</span><span class="run77"><a name="line697" /> 697     vector.each_with_index {|item,index| vector[index] = item * 20**index}
<a name="line698" /> 698     @signature=vector.inject(0) {|sum,n| sum+n}
</span><a name="line699" /> 699   end
<a name="line700" /> 700   
<span class="run59"><a name="line701" /> 701   def self.eliminate_terms(q, n, d)
</span><span class="run64"><a name="line702" /> 702     num = n.clone
</span><span class="run59"><a name="line703" /> 703     den = d.clone
</span><a name="line704" /> 704     
<span class="run64"><a name="line705" /> 705     num.delete_if {|v| v == '&lt;1&gt;'}
</span><span class="run59"><a name="line706" /> 706     den.delete_if {|v| v == '&lt;1&gt;'}
<a name="line707" /> 707     combined = Hash.new(0)
</span><a name="line708" /> 708  
<span class="run59"><a name="line709" /> 709     i = 0
<a name="line710" /> 710     loop do 
</span><span class="run72"><a name="line711" /> 711       break if i &gt; num.size
</span><span class="run69"><a name="line712" /> 712       if @@PREFIX_VALUES.has_key? num[i]
</span><a name="line713" /> 713         k = [num[i],num[i+1]]
<a name="line714" /> 714         i += 2
<a name="line715" /> 715       else
<span class="run64"><a name="line716" /> 716         k = num[i]
<a name="line717" /> 717         i += 1
</span><a name="line718" /> 718       end
<span class="run69"><a name="line719" /> 719       combined[k] += 1 unless k.nil? || k == '&lt;1&gt;'
</span><a name="line720" /> 720     end
<a name="line721" /> 721     
<span class="run59"><a name="line722" /> 722     j = 0
<a name="line723" /> 723     loop do
</span><span class="run69"><a name="line724" /> 724       break if j &gt; den.size
</span><span class="run64"><a name="line725" /> 725         if @@PREFIX_VALUES.has_key? den[j]
</span><a name="line726" /> 726           k = [den[j],den[j+1]]
<a name="line727" /> 727           j += 2
<a name="line728" /> 728         else
<span class="run59"><a name="line729" /> 729           k = den[j]
<a name="line730" /> 730           j += 1
</span><a name="line731" /> 731         end
<span class="run64"><a name="line732" /> 732       combined[k] -= 1 unless k.nil? || k == '&lt;1&gt;'
</span><a name="line733" /> 733     end
<a name="line734" /> 734  
<span class="run59"><a name="line735" /> 735     num = []
<a name="line736" /> 736     den = []
<a name="line737" /> 737     combined.each do |key,value| 
</span><a name="line738" /> 738       case 
<span class="run67"><a name="line739" /> 739       when value &gt; 0 : value.times {num &lt;&lt; key}
</span><a name="line740" /> 740       when value &lt; 0 : value.abs.times {den &lt;&lt; key}
<span class="run59"><a name="line741" /> 741       end
</span><a name="line742" /> 742     end
<span class="run64"><a name="line743" /> 743     num = [&quot;&lt;1&gt;&quot;] if num.empty?
<a name="line744" /> 744     den = [&quot;&lt;1&gt;&quot;] if den.empty?
</span><span class="run59"><a name="line745" /> 745     {:scalar=&gt;q, :numerator=&gt;num.flatten.compact, :denominator=&gt;den.flatten.compact}
</span><a name="line746" /> 746   end
<a name="line747" /> 747       
<a name="line748" /> 748   
<a name="line749" /> 749   # parse a string into a unit object.
<a name="line750" /> 750   # Typical formats like : 
<a name="line751" /> 751   #  &quot;5.6 kg*m/s^2&quot;
<a name="line752" /> 752   #  &quot;5.6 kg*m*s^-2&quot;
<a name="line753" /> 753   #  &quot;5.6 kilogram*meter*second^-2&quot;
<a name="line754" /> 754   #  &quot;2.2 kPa&quot;
<a name="line755" /> 755   #  &quot;37 degC&quot;
<a name="line756" /> 756   #  &quot;1&quot;  -- creates a unitless constant with value 1
<a name="line757" /> 757   #  &quot;GPa&quot;  -- creates a unit with scalar 1 with units 'GPa'
<a name="line758" /> 758   #  6'4&quot;  -- recognized as 6 feet + 4 inches
<a name="line759" /> 759   #  8 lbs 8 oz -- recognized as 8 lbs + 8 ounces 
<span class="run52"><a name="line760" /> 760   def parse(unit_string=&quot;0&quot;)
</span><span class="run57"><a name="line761" /> 761     @numerator = ['&lt;1&gt;']
</span><span class="run52"><a name="line762" /> 762     @denominator = ['&lt;1&gt;']
<a name="line763" /> 763     unit_string.gsub!(/[&lt;&gt;]/,&quot;&quot;)
</span><a name="line764" /> 764      
<a name="line765" /> 765     # Special processing for unusual unit strings
<a name="line766" /> 766     # feet -- 6'5&quot;
<span class="run52"><a name="line767" /> 767     feet, inches = unit_string.scan(/(\d+)\s*(?:'|ft|feet)\s*(\d+)\s*(?:&quot;|in|inches)/)[0]
</span><span class="run60"><a name="line768" /> 768     if (feet &amp;&amp; inches)
</span><a name="line769" /> 769       result = Unit.new(&quot;#{feet} ft&quot;) + Unit.new(&quot;#{inches} inches&quot;)
<a name="line770" /> 770       @scalar = result.scalar
<a name="line771" /> 771       @numerator = result.numerator
<a name="line772" /> 772       @denominator = result.denominator
<a name="line773" /> 773       @base_scalar = result.base_scalar
<a name="line774" /> 774       return self
<a name="line775" /> 775     end
<a name="line776" /> 776 
<a name="line777" /> 777     # weight -- 8 lbs 12 oz    
<span class="run52"><a name="line778" /> 778     pounds, oz = unit_string.scan(/(\d+)\s*(?:#|lbs|pounds)+[\s,]*(\d+)\s*(?:oz|ounces)/)[0]
</span><span class="run60"><a name="line779" /> 779     if (pounds &amp;&amp; oz)
</span><a name="line780" /> 780       result = Unit.new(&quot;#{pounds} lbs&quot;) + Unit.new(&quot;#{oz} oz&quot;)
<a name="line781" /> 781       @scalar = result.scalar
<a name="line782" /> 782       @numerator = result.numerator
<a name="line783" /> 783       @denominator = result.denominator
<a name="line784" /> 784       @base_scalar = result.base_scalar
<a name="line785" /> 785       return self
<a name="line786" /> 786     end
<span class="run52"><a name="line787" /> 787     @scalar, top, bottom = unit_string.scan(/([\dEe+.-]*)\s*([^\/]*)\/*(.+)*/)[0]  #parse the string into parts
</span><a name="line788" /> 788     
<span class="run52"><a name="line789" /> 789     top.scan(/([^ \*]+)(?:\^|\*\*)([\d-]+)/).each do |item|
</span><a name="line790" /> 790       n = item[1].to_i
<a name="line791" /> 791       x = &quot;#{item[0]} &quot;
<a name="line792" /> 792       case 
<a name="line793" /> 793         when n&gt;=0 : top.gsub!(/#{item[0]}(\^|\*\*)#{n}/) {|s| x * n}
<a name="line794" /> 794         when n&lt;0 : bottom = &quot;#{bottom} #{x * -n}&quot;; top.gsub!(/#{item[0]}(\^|\*\*)#{n}/,&quot;&quot;)
<a name="line795" /> 795       end
<a name="line796" /> 796     end 
<a name="line797" /> 797 
<span class="run57"><a name="line798" /> 798     bottom.gsub!(/([^* ]+)(?:\^|\*\*)(\d+)/) {|s| &quot;#{$1} &quot; * $2.to_i} if bottom
<a name="line799" /> 799     if @scalar.empty?
</span><span class="run50"><a name="line800" /> 800       if top =~ /[\dEe+.-]+/
</span><a name="line801" /> 801         @scalar = top.to_f  # need this for 'number only' initialization
<a name="line802" /> 802       else
<span class="run44"><a name="line803" /> 803         @scalar = 1         # need this for 'unit only' intialization
</span><a name="line804" /> 804       end
<a name="line805" /> 805     else
<span class="run50"><a name="line806" /> 806       @scalar = @scalar.to_f
</span><a name="line807" /> 807     end
<a name="line808" /> 808             
<span class="run62"><a name="line809" /> 809     @numerator = top.scan(/(#{@@PREFIX_REGEX})*?(#{@@UNIT_REGEX})\b/).delete_if {|x| x.empty?}.compact if top
</span><span class="run57"><a name="line810" /> 810     @denominator = bottom.scan(/(#{@@PREFIX_REGEX})*?(#{@@UNIT_REGEX})\b/).delete_if {|x| x.empty?}.compact if bottom
</span><a name="line811" /> 811 
<span class="run52"><a name="line812" /> 812     @numerator = @numerator.map do |item|
</span><span class="run71"><a name="line813" /> 813       item.map {|x| (x) if x}
</span><span class="run62"><a name="line814" /> 814        @@PREFIX_MAP[item[0]] ? [@@PREFIX_MAP[item[0]], @@UNIT_MAP[item[1]]] : [@@UNIT_MAP[item[1]]]
</span><span class="run56"><a name="line815" /> 815     end.flatten.compact.delete_if {|x| x.empty?}
</span><a name="line816" /> 816 
<span class="run52"><a name="line817" /> 817     @denominator = @denominator.map do |item|
</span><span class="run62"><a name="line818" /> 818        item.map {|x| (x) if x}
</span><span class="run57"><a name="line819" /> 819        @@PREFIX_MAP[item[0]] ? [@@PREFIX_MAP[item[0]], @@UNIT_MAP[item[1]]] : [@@UNIT_MAP[item[1]]]
</span><a name="line820" /> 820     end.flatten.compact.delete_if {|x| x.empty?}
<a name="line821" /> 821 
<span class="run57"><a name="line822" /> 822     @numerator = ['&lt;1&gt;'] if @numerator.empty?    
<a name="line823" /> 823     @denominator = ['&lt;1&gt;'] if @denominator.empty?
</span><span class="run52"><a name="line824" /> 824     self
</span><a name="line825" /> 825   end 
<a name="line826" /> 826 end
<a name="line827" /> 827 
<a name="line828" /> 828 
<a name="line829" /> 829 # Allow date objects to do offsets by a time unit
<a name="line830" /> 830 # Date.today + U&quot;1 week&quot; =&gt; gives today+1 week
<span class="run16"><a name="line831" /> 831 class Date
</span><span class="run11"><a name="line832" /> 832   alias :unit_date_add :+
<a name="line833" /> 833   def +(unit)
</span><a name="line834" /> 834     case unit
<a name="line835" /> 835     when Unit:
<a name="line836" /> 836       unit = unit.to('d').round if ['y', 'decade', 'century'].include? unit.units 
<a name="line837" /> 837       unit_date_add(unit.to('day').scalar)
<a name="line838" /> 838     when Time: unit_date_add(unit.to_datetime)
<a name="line839" /> 839     else
<a name="line840" /> 840       unit_date_add(unit)
<a name="line841" /> 841     end
<a name="line842" /> 842   end
<a name="line843" /> 843 
<span class="run11"><a name="line844" /> 844   alias :unit_date_sub :-    
<a name="line845" /> 845   def -(unit)
</span><a name="line846" /> 846     case unit
<a name="line847" /> 847     when Unit: 
<a name="line848" /> 848       unit = unit.to('d').round if ['y', 'decade', 'century'].include? unit.units 
<a name="line849" /> 849       unit_date_sub(unit.to('day').scalar)
<a name="line850" /> 850     when Time: unit_date_sub(unit.to_datetime)
<a name="line851" /> 851     else
<a name="line852" /> 852       unit_date_sub(unit)
<a name="line853" /> 853     end
<a name="line854" /> 854   end
<a name="line855" /> 855   
<span class="run11"><a name="line856" /> 856   def to_time
</span><a name="line857" /> 857     Time.local(*ParseDate.parsedate(self.to_s))
<a name="line858" /> 858   end
<a name="line859" /> 859   
<span class="run11"><a name="line860" /> 860   alias :units_datetime_inspect :inspect
<a name="line861" /> 861   def inspect(raw = false)
</span><a name="line862" /> 862     return self.units_datetime_inspect if raw
<a name="line863" /> 863     self.to_s
<a name="line864" /> 864   end
<a name="line865" /> 865   
<a name="line866" /> 866 end
<a name="line867" /> 867 
<span class="run16"><a name="line868" /> 868 class Object
</span><span class="run11"><a name="line869" /> 869   def Unit(other)
</span><a name="line870" /> 870     other.to_unit
<a name="line871" /> 871   end
<span class="run11"><a name="line872" /> 872   alias :U :Unit
<a name="line873" /> 873   alias :u :Unit
</span><a name="line874" /> 874 end
<a name="line875" /> 875 
<a name="line876" /> 876 # make a unitless unit with a given scalar
<span class="run16"><a name="line877" /> 877 class Numeric
</span><span class="run11"><a name="line878" /> 878   def to_unit(other = nil)
</span><a name="line879" /> 879     other ? Unit.new(self) * Unit.new(other) : Unit.new(self)
<a name="line880" /> 880   end
<span class="run11"><a name="line881" /> 881   alias :unit :to_unit
<a name="line882" /> 882   alias :u :to_unit
</span><a name="line883" /> 883 end
<a name="line884" /> 884 
<a name="line885" /> 885 # make a unit from an array
<a name="line886" /> 886 # [1, 'mm'].unit =&gt; 1 mm
<span class="run16"><a name="line887" /> 887 class Array
</span><span class="run11"><a name="line888" /> 888   def to_unit(other = nil)
</span><a name="line889" /> 889     other ? Unit.new(self).to(other) : Unit.new(self)
<a name="line890" /> 890   end
<span class="run11"><a name="line891" /> 891   alias :unit :to_unit
<a name="line892" /> 892   alias :u :to_unit
</span><a name="line893" /> 893 end
<a name="line894" /> 894 
<a name="line895" /> 895 # make a string into a unit
<span class="run16"><a name="line896" /> 896 class String
</span><span class="run50"><a name="line897" /> 897   def to_unit(other = nil)
</span><span class="run55"><a name="line898" /> 898     other ? Unit.new(self) &gt;&gt; other : Unit.new(self)
</span><span class="run50"><a name="line899" /> 899   end
</span><span class="run11"><a name="line900" /> 900   alias :unit :to_unit
<a name="line901" /> 901   alias :u :to_unit
<a name="line902" /> 902   alias :unit_format :%
</span><a name="line903" /> 903   
<a name="line904" /> 904   # format unit output using formating codes '%0.2f' % '1 mm'.unit =&gt; '1.00 mm'
<span class="run11"><a name="line905" /> 905   def %(*args)
</span><a name="line906" /> 906     case args[0]
<a name="line907" /> 907     when Unit: args[0].to_s(self)
<a name="line908" /> 908     when Complex: args[0].to_s
<a name="line909" /> 909     else
<a name="line910" /> 910       unit_format(*args)
<a name="line911" /> 911     end
<a name="line912" /> 912   end
<a name="line913" /> 913     
<span class="run11"><a name="line914" /> 914   def from(time_point = ::Time.now)
</span><a name="line915" /> 915     self.unit.from(time_point)
<a name="line916" /> 916   end
<span class="run11"><a name="line917" /> 917   alias :after :from
<a name="line918" /> 918   alias :from_now :from
</span><a name="line919" /> 919   
<span class="run11"><a name="line920" /> 920   def ago
</span><a name="line921" /> 921     self.unit.ago
<a name="line922" /> 922   end
<a name="line923" /> 923   
<span class="run11"><a name="line924" /> 924   def before(time_point = ::Time.now)
</span><a name="line925" /> 925     self.unit.before(time_point)
<a name="line926" /> 926   end
<span class="run11"><a name="line927" /> 927   alias :before_now :before
</span><a name="line928" /> 928   
<span class="run11"><a name="line929" /> 929   def since(time_point = ::Time.now)
</span><a name="line930" /> 930     self.unit.since(time_point)
<a name="line931" /> 931   end
<a name="line932" /> 932   
<span class="run11"><a name="line933" /> 933   def until(time_point = ::Time.now)
</span><a name="line934" /> 934     self.unit.until(time_point)
<a name="line935" /> 935   end
<a name="line936" /> 936   
<span class="run11"><a name="line937" /> 937   def to(other)
</span><a name="line938" /> 938     self.unit.to(other)
<a name="line939" /> 939   end
<a name="line940" /> 940   
<span class="run11"><a name="line941" /> 941   def time(options = {})
</span><a name="line942" /> 942     self.to_time(options) rescue self.to_datetime(options)
<a name="line943" /> 943   end
<a name="line944" /> 944   
<span class="run11"><a name="line945" /> 945   def to_time(options = {})
</span><a name="line946" /> 946     begin
<a name="line947" /> 947       #raises exception when Chronic not defined or when it returns a nil (i.e., can't parse the input)
<a name="line948" /> 948       r = Chronic.parse(self,options)
<a name="line949" /> 949       raise(ArgumentError, 'Invalid Time String') unless r
<a name="line950" /> 950       return r
<a name="line951" /> 951     rescue
<a name="line952" /> 952       Time.local(*ParseDate.parsedate(self))
<a name="line953" /> 953     end
<a name="line954" /> 954   end
<a name="line955" /> 955   
<span class="run11"><a name="line956" /> 956   def to_datetime(options = {})
</span><a name="line957" /> 957     begin
<a name="line958" /> 958       # raises an exception if Chronic.parse = nil or if Chronic not defined
<a name="line959" /> 959       r = Chronic.parse(self,options).to_datetime
<a name="line960" /> 960     rescue
<a name="line961" /> 961       r=DateTime.civil(*ParseDate.parsedate(self)[0..5].compact)
<a name="line962" /> 962     end
<a name="line963" /> 963     raise RuntimeError, &quot;Invalid Time String&quot; if r == DateTime.new      
<a name="line964" /> 964     return r
<a name="line965" /> 965   end
<a name="line966" /> 966   
<span class="run11"><a name="line967" /> 967   def to_date(options={})
</span><a name="line968" /> 968     begin
<a name="line969" /> 969       r = Chronic.parse(self,options).to_date
<a name="line970" /> 970     rescue
<a name="line971" /> 971       r = Date.civil(*ParseDate.parsedate(self)[0..5].compact)
<a name="line972" /> 972     end
<a name="line973" /> 973     raise RuntimeError, 'Invalid Date String' if r == Date.new
<a name="line974" /> 974     return r
<a name="line975" /> 975   end
<a name="line976" /> 976 
<span class="run11"><a name="line977" /> 977   def datetime(options = {})
</span><a name="line978" /> 978     self.to_datetime(options) rescue self.to_time(options)
<a name="line979" /> 979   end
<a name="line980" /> 980 end
<a name="line981" /> 981 
<a name="line982" /> 982 
<a name="line983" /> 983 # Allow time objects to use 
<span class="run16"><a name="line984" /> 984 class Time
</span><a name="line985" /> 985   
<span class="run16"><a name="line986" /> 986   class &lt;&lt; self
</span><span class="run11"><a name="line987" /> 987     alias unit_time_at at
</span><a name="line988" /> 988   end
<a name="line989" /> 989   
<span class="run11"><a name="line990" /> 990   def self.at(*args)
</span><a name="line991" /> 991     if Unit === args[0]
<a name="line992" /> 992       unit_time_at(args[0].to(&quot;s&quot;).scalar)
<a name="line993" /> 993     else
<a name="line994" /> 994       unit_time_at(*args)
<a name="line995" /> 995     end
<a name="line996" /> 996   end
<a name="line997" /> 997   
<span class="run11"><a name="line998" /> 998   def to_unit(other = &quot;s&quot;)
</span><a name="line999" /> 999     other ? Unit.new(&quot;#{self.to_f} s&quot;).to(other) : Unit.new(&quot;#{self.to_f} s&quot;)
<a name="line1000" />1000   end
<span class="run11"><a name="line1001" />1001   alias :unit :to_unit
<a name="line1002" />1002   alias :u :to_unit
<a name="line1003" />1003   alias :unit_add :+
</span><a name="line1004" />1004   
<span class="run11"><a name="line1005" />1005   def to_datetime
</span><a name="line1006" />1006     DateTime.civil(1970,1,1)+(self.to_f+self.gmt_offset)/86400
<a name="line1007" />1007   end
<a name="line1008" />1008   
<span class="run11"><a name="line1009" />1009   def to_date
</span><a name="line1010" />1010     Date.civil(1970,1,1)+(self.to_f+self.gmt_offset)/86400
<a name="line1011" />1011   end
<a name="line1012" />1012   
<span class="run11"><a name="line1013" />1013   def +(other)
</span><a name="line1014" />1014     case other
<a name="line1015" />1015     when Unit: unit_add(other.to('s').scalar)
<a name="line1016" />1016     when DateTime: unit_add(other.to_time)
<a name="line1017" />1017     else
<a name="line1018" />1018       unit_add(other)
<a name="line1019" />1019     end
<a name="line1020" />1020   end
<a name="line1021" />1021   
<span class="run11"><a name="line1022" />1022   def self.in(duration)
</span><a name="line1023" />1023     Time.now + duration.to_unit
<a name="line1024" />1024   end
<a name="line1025" />1025   
<span class="run11"><a name="line1026" />1026   alias :unit_sub :-
<a name="line1027" />1027   def -(other)
</span><a name="line1028" />1028     case other
<a name="line1029" />1029     when Unit: unit_sub(other.to('s').scalar)
<a name="line1030" />1030     when DateTime: unit_sub(other.to_time)
<a name="line1031" />1031     else
<a name="line1032" />1032       unit_sub(other)
<a name="line1033" />1033     end
<a name="line1034" />1034   end
<a name="line1035" />1035 end
<a name="line1036" />1036 
<span class="run16"><a name="line1037" />1037 module Math
</span><span class="run11"><a name="line1038" />1038   alias unit_sin sin
<a name="line1039" />1039    def sin(n)
</span><a name="line1040" />1040      if Unit === n
<a name="line1041" />1041        unit_sin(n.to('radian').scalar)
<a name="line1042" />1042      else
<a name="line1043" />1043        unit_sin(n)
<a name="line1044" />1044      end
<a name="line1045" />1045    end
<a name="line1046" />1046 
<span class="run11"><a name="line1047" />1047    alias unit_cos cos
<a name="line1048" />1048     def cos(n)
</span><a name="line1049" />1049       if Unit === n
<a name="line1050" />1050         unit_cos(n.to('radian').scalar)
<a name="line1051" />1051       else
<a name="line1052" />1052         unit_cos(n)
<a name="line1053" />1053       end
<a name="line1054" />1054     end
<a name="line1055" />1055     
<span class="run11"><a name="line1056" />1056     alias unit_sinh sinh
<a name="line1057" />1057      def sinh(n)
</span><a name="line1058" />1058        if Unit === n
<a name="line1059" />1059          unit_sinh(n.to('radian').scalar)
<a name="line1060" />1060        else
<a name="line1061" />1061          unit_sinh(n)
<a name="line1062" />1062        end
<a name="line1063" />1063      end
<a name="line1064" />1064 
<span class="run11"><a name="line1065" />1065      alias unit_cosh cosh
<a name="line1066" />1066       def cosh(n)
</span><a name="line1067" />1067         if Unit === n
<a name="line1068" />1068           unit_cosh(n.to('radian').scalar)
<a name="line1069" />1069         else
<a name="line1070" />1070           unit_cosh(n)
<a name="line1071" />1071         end
<a name="line1072" />1072       end
<a name="line1073" />1073 
<span class="run11"><a name="line1074" />1074       alias unit_tan tan
<a name="line1075" />1075        def tan(n)
</span><a name="line1076" />1076          if Unit === n
<a name="line1077" />1077            unit_tan(n.to('radian').scalar)
<a name="line1078" />1078          else
<a name="line1079" />1079            unit_tan(n)
<a name="line1080" />1080          end
<a name="line1081" />1081        end
<a name="line1082" />1082 
<span class="run11"><a name="line1083" />1083        alias unit_tanh tanh
<a name="line1084" />1084         def tanh(n)
</span><a name="line1085" />1085           if Unit === n
<a name="line1086" />1086             unit_tanh(n.to('radian').scalar)
<a name="line1087" />1087           else
<a name="line1088" />1088             unit_tanh(n)
<a name="line1089" />1089           end
<a name="line1090" />1090         end
<a name="line1091" />1091 
<span class="run11"><a name="line1092" />1092    module_function :unit_sin
<a name="line1093" />1093    module_function :sin
<a name="line1094" />1094    module_function :unit_cos
<a name="line1095" />1095    module_function :cos
<a name="line1096" />1096    module_function :unit_sinh
<a name="line1097" />1097    module_function :sinh
<a name="line1098" />1098    module_function :unit_cosh
<a name="line1099" />1099    module_function :cosh
<a name="line1100" />1100    module_function :unit_tan
<a name="line1101" />1101    module_function :tan
<a name="line1102" />1102    module_function :unit_tanh
<a name="line1103" />1103    module_function :tanh
</span><a name="line1104" />1104 end
</pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.7.0.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
